From 961d1db17ff95313d295713cb299b4b1cfdb1f54 Mon Sep 17 00:00:00 2001
From: MagneFire <IDaNLContact@gmail.com>
Date: Sat, 13 Feb 2021 17:01:29 +0100
Subject: [PATCH] mdss: Import video driver from Marshmallow. For some reason a
 garbled output is observed when using Nougat based kernels. Using the
 Marshmallow implementation fixes this.

---
 drivers/clk/msm/mdss/mdss-pll-util.c          |  19 +-
 drivers/video/msm/mdss/Kconfig                |  15 +
 drivers/video/msm/mdss/dsi_status_v2.c        |  88 +--
 drivers/video/msm/mdss/dsi_v2.c               |  23 +-
 drivers/video/msm/mdss/mdp3.c                 |  66 +-
 drivers/video/msm/mdss/mdp3.h                 |   2 -
 drivers/video/msm/mdss/mdp3_ctrl.c            | 180 ++---
 drivers/video/msm/mdss/mdp3_dma.c             |  10 +-
 drivers/video/msm/mdss/mdp3_dma.h             |   3 +-
 drivers/video/msm/mdss/mdp3_ppp.c             |  29 +-
 drivers/video/msm/mdss/mdp3_ppp_hwio.c        |  11 +-
 drivers/video/msm/mdss/mdss.h                 |   1 +
 drivers/video/msm/mdss/mdss_compat_utils.c    |  30 +-
 drivers/video/msm/mdss/mdss_debug.c           |  63 +-
 drivers/video/msm/mdss/mdss_debug_xlog.c      |  14 +-
 drivers/video/msm/mdss/mdss_dsi.c             | 198 ++----
 drivers/video/msm/mdss/mdss_dsi.h             |  31 +-
 drivers/video/msm/mdss/mdss_dsi_clk.c         |   6 +-
 drivers/video/msm/mdss/mdss_dsi_cmd.c         |   2 -
 drivers/video/msm/mdss/mdss_dsi_host.c        |  11 +-
 drivers/video/msm/mdss/mdss_dsi_panel.c       | 393 +++--------
 drivers/video/msm/mdss/mdss_dsi_status.c      |  11 +-
 drivers/video/msm/mdss/mdss_fb.c              | 627 +-----------------
 drivers/video/msm/mdss/mdss_fb.h              |   1 -
 drivers/video/msm/mdss/mdss_hdmi_tx.c         |  14 +-
 drivers/video/msm/mdss/mdss_io_util.c         |  56 +-
 drivers/video/msm/mdss/mdss_mdp.c             |  12 +-
 drivers/video/msm/mdss/mdss_mdp_ctl.c         |  16 +-
 drivers/video/msm/mdss/mdss_mdp_intf_cmd.c    |   6 +-
 drivers/video/msm/mdss/mdss_mdp_intf_video.c  |  10 +-
 drivers/video/msm/mdss/mdss_mdp_layer.c       |   4 +-
 drivers/video/msm/mdss/mdss_mdp_overlay.c     |  28 +-
 drivers/video/msm/mdss/mdss_mdp_pipe.c        |   4 +-
 drivers/video/msm/mdss/mdss_mdp_pp.c          |  82 +--
 .../video/msm/mdss/mdss_mdp_pp_cache_config.c |  66 +-
 drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c     |  82 +--
 drivers/video/msm/mdss/mdss_mdp_rotator.c     |   6 +-
 drivers/video/msm/mdss/mdss_mdp_util.c        |   9 +-
 drivers/video/msm/mdss/mdss_mdp_wb.c          |  10 +-
 drivers/video/msm/mdss/mdss_panel.c           |  10 +-
 drivers/video/msm/mdss/mdss_panel.h           |  18 +-
 drivers/video/msm/mdss/mdss_rotator.c         |   9 +-
 drivers/video/msm/mdss/mdss_util.c            |   2 +-
 drivers/video/msm/mdss/mhl3/mhl_linux_tx.c    |   2 +-
 drivers/video/msm/mdss/mhl3/mhl_supp.c        |  12 +-
 drivers/video/msm/mdss/mhl3/platform.c        |   6 +-
 drivers/video/msm/mdss/mhl3/si_8620_drv.c     |   4 +-
 drivers/video/msm/mdss/mhl3/si_emsc_hid.c     |   4 +-
 drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c |  25 +-
 drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c |  25 +-
 drivers/video/msm/mdss/msm_mdss_io_8974.c     |  23 +-
 include/linux/mdss_io_util.h                  |  15 +-
 52 files changed, 596 insertions(+), 1798 deletions(-)
 mode change 100755 => 100644 drivers/video/msm/mdss/mdp3_ctrl.c
 mode change 100755 => 100644 drivers/video/msm/mdss/mdss_dsi_host.c
 mode change 100755 => 100644 drivers/video/msm/mdss/mdss_fb.c

diff --git a/drivers/clk/msm/mdss/mdss-pll-util.c b/drivers/clk/msm/mdss/mdss-pll-util.c
index dfb95ad4e54..3f1ccb38abc 100644
--- a/drivers/clk/msm/mdss/mdss-pll-util.c
+++ b/drivers/clk/msm/mdss/mdss-pll-util.c
@@ -218,7 +218,7 @@ static int mdss_pll_util_parse_dt_supply(struct platform_device *pdev,
 			pr_err(": error reading enable load. rc=%d\n", rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_ENABLE] = tmp;
+		mp->vreg_config[i].enable_load = tmp;
 
 		rc = of_property_read_u32(supply_node,
 					"qcom,supply-disable-load", &tmp);
@@ -226,15 +226,7 @@ static int mdss_pll_util_parse_dt_supply(struct platform_device *pdev,
 			pr_err(": error reading disable load. rc=%d\n", rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_DISABLE] = tmp;
-
-		rc = of_property_read_u32(supply_node,
-					"qcom,supply-ulp-load", &tmp);
-		if (rc)
-			pr_warn(": error reading ulp load. rc=%d\n", rc);
-
-		mp->vreg_config[i].load[DSS_REG_MODE_ULP] = (!rc ? tmp :
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE]);
+		mp->vreg_config[i].disable_load = tmp;
 
 		rc = of_property_read_u32(supply_node,
 					"qcom,supply-pre-on-sleep", &tmp);
@@ -268,13 +260,12 @@ static int mdss_pll_util_parse_dt_supply(struct platform_device *pdev,
 
 		mp->vreg_config[i].post_off_sleep = (!rc ? tmp : 0);
 
-		pr_debug("%s min=%d, max=%d, enable=%d, disable=%d, ulp=%d, preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
+		pr_debug("%s min=%d, max=%d, enable=%d, disable=%d, preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
 					mp->vreg_config[i].vreg_name,
 					mp->vreg_config[i].min_voltage,
 					mp->vreg_config[i].max_voltage,
-					mp->vreg_config[i].load[DSS_REG_MODE_ENABLE],
-					mp->vreg_config[i].load[DSS_REG_MODE_DISABLE],
-					mp->vreg_config[i].load[DSS_REG_MODE_ULP],
+					mp->vreg_config[i].enable_load,
+					mp->vreg_config[i].disable_load,
 					mp->vreg_config[i].pre_on_sleep,
 					mp->vreg_config[i].post_on_sleep,
 					mp->vreg_config[i].pre_off_sleep,
diff --git a/drivers/video/msm/mdss/Kconfig b/drivers/video/msm/mdss/Kconfig
index 3029d0ef749..b8e9fcd63da 100644
--- a/drivers/video/msm/mdss/Kconfig
+++ b/drivers/video/msm/mdss/Kconfig
@@ -62,3 +62,18 @@ config FB_MSM_MDSS_XLOG_DEBUG
 	features to: Dump MDSS registers during driver errors, panic
 	driver during fatal errors and enable some display-driver logging
 	into an internal buffer (this avoids logging overhead).
+
+config KEEP_POWER_ON_WHEN_PANEL_OFF
+	bool "Enable Keep Panel Power On When Panel Off"
+	default n
+	---help---
+	For some reason, shutting down panel power when panel off is more
+	time and power consuming because it will take more time and power
+	on panel on sequence. Set this option true if you don't want to
+	turn panel power off when panel off.
+
+config ASUS_BACKLIGHT_DEBUG
+    bool 'enable backlight debug mode'
+    default n
+    ---help---
+        Enable backlight debug mode
diff --git a/drivers/video/msm/mdss/dsi_status_v2.c b/drivers/video/msm/mdss/dsi_status_v2.c
index 3c744d796f7..58e24023436 100644
--- a/drivers/video/msm/mdss/dsi_status_v2.c
+++ b/drivers/video/msm/mdss/dsi_status_v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -9,47 +9,16 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
+
 #include <linux/workqueue.h>
 #include <linux/delay.h>
 #include <linux/kobject.h>
 #include <linux/string.h>
 #include <linux/sysfs.h>
-#include <linux/interrupt.h>
 
 #include "mdss_dsi.h"
 #include "mdp3_ctrl.h"
 
-/*
- * mdp3_check_te_status() - Check the status of panel for TE based ESD.
- * @ctrl_pdata   : dsi controller data
- * @pstatus_data : dsi status data
- * @frame_rate   : panel frame rate
- *
- * This function waits for TE signal from the panel for a maximum
- * duration of 3 vsyncs. If timeout occurs, report the panel to be
- * dead due to ESD attack.
- * NOTE: The TE IRQ handling is linked to the ESD thread scheduling,
- * i.e. rate of TE IRQs firing is bound by the ESD interval.
- */
-static int mdp3_check_te_status(struct mdss_dsi_ctrl_pdata *ctrl_pdata,
-		struct dsi_status_data *pstatus_data, int frame_rate)
-{
-	int ret;
-
-	pr_debug("%s: Checking panel TE status\n", __func__);
-
-	atomic_set(&ctrl_pdata->te_irq_ready, 0);
-	reinit_completion(&ctrl_pdata->te_irq_comp);
-	enable_irq(gpio_to_irq(ctrl_pdata->disp_te_gpio));
-
-	ret = wait_for_completion_timeout(&ctrl_pdata->te_irq_comp,
-			msecs_to_jiffies((1000 / frame_rate) * 3));
-
-	disable_irq(gpio_to_irq(ctrl_pdata->disp_te_gpio));
-	pr_debug("%s: Panel TE check done with ret = %d\n", __func__, ret);
-	return ret;
-}
-
 /*
  * mdp3_check_dsi_ctrl_status() - Check MDP3 DSI controller status periodically.
  * @work     : dsi controller status data
@@ -64,7 +33,6 @@ void mdp3_check_dsi_ctrl_status(struct work_struct *work,
 {
 	struct dsi_status_data *pdsi_status = NULL;
 	struct mdss_panel_data *pdata = NULL;
-	struct mipi_panel_info *mipi = NULL;
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 	struct mdp3_session_data *mdp3_session = NULL;
 	int ret = 0;
@@ -83,25 +51,15 @@ void mdp3_check_dsi_ctrl_status(struct work_struct *work,
 		return;
 	}
 
-	mipi = &pdata->panel_info.mipi;
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 							panel_data);
 
-	if (!ctrl_pdata || (!ctrl_pdata->check_status &&
-		(ctrl_pdata->status_mode != ESD_TE))) {
+	if (!ctrl_pdata || !ctrl_pdata->check_status) {
 		pr_err("%s: DSI ctrl or status_check callback not available\n",
 								__func__);
 		return;
 	}
 
-	if (!pdata->panel_info.esd_rdy) {
-		pr_err("%s: unblank not complete, reschedule check status\n",
-			__func__);
-		schedule_delayed_work(&pdsi_status->check_status,
-				msecs_to_jiffies(interval));
-		return;
-	}
-
 	mdp3_session = pdsi_status->mfd->mdp.private1;
 	if (!mdp3_session) {
 		pr_err("%s: Display is off\n", __func__);
@@ -115,19 +73,10 @@ void mdp3_check_dsi_ctrl_status(struct work_struct *work,
 		return;
 	}
 
-	if (mipi->mode == DSI_CMD_MODE &&
-		mipi->hw_vsync_mode &&
-		mdss_dsi_is_te_based_esd(ctrl_pdata)) {
-		int frame_rate = mdss_panel_get_framerate(&pdata->panel_info);
-
-		if (mdp3_check_te_status(ctrl_pdata, pdsi_status,
-					 frame_rate) > 0)
-			goto sim;
-		goto status_dead;
-	}
-
+	mutex_lock(&mdp3_session->lock);
 	if (!mdp3_session->status) {
 		pr_debug("%s: display off already\n", __func__);
+		mutex_unlock(&mdp3_session->lock);
 		return;
 	}
 
@@ -138,24 +87,21 @@ void mdp3_check_dsi_ctrl_status(struct work_struct *work,
 		ret = ctrl_pdata->check_status(ctrl_pdata);
 	else
 		pr_err("%s: wait_for_dma_done error\n", __func__);
+	mutex_unlock(&mdp3_session->lock);
 
-	if (mdss_fb_is_power_on(pdsi_status->mfd)) {
-		if (ret > 0)
+	if (mdss_fb_is_power_on_interactive(pdsi_status->mfd)) {
+		if (ret > 0) {
 			schedule_delayed_work(&pdsi_status->check_status,
 						msecs_to_jiffies(interval));
-		else
-			goto status_dead;
+		} else {
+			char *envp[2] = {"PANEL_ALIVE=0", NULL};
+			pdata->panel_info.panel_dead = true;
+			ret = kobject_uevent_env(
+					&pdsi_status->mfd->fbi->dev->kobj,
+					KOBJ_CHANGE, envp);
+			pr_err("%s: Panel has gone bad, sending uevent - %s\n",
+							__func__, envp[0]);
+		}
 	}
-sim:
-	if (pdata->panel_info.panel_force_dead) {
-		pr_debug("force_dead=%d\n", pdata->panel_info.panel_force_dead);
-		pdata->panel_info.panel_force_dead--;
-		if (!pdata->panel_info.panel_force_dead)
-			goto status_dead;
-	}
-	return;
-
-status_dead:
-	mdss_fb_report_panel_dead(pdsi_status->mfd);
 }
 
diff --git a/drivers/video/msm/mdss/dsi_v2.c b/drivers/video/msm/mdss/dsi_v2.c
index 1b93e24d37d..c6e079e26c5 100644
--- a/drivers/video/msm/mdss/dsi_v2.c
+++ b/drivers/video/msm/mdss/dsi_v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -334,7 +334,7 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 				__func__, rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_ENABLE] = tmp;
+		mp->vreg_config[i].enable_load = tmp;
 
 		/* disable-load */
 		rc = of_property_read_u32(supply_node,
@@ -344,17 +344,7 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 				__func__, rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_DISABLE] = tmp;
-
-		/* ulp-load */
-		rc = of_property_read_u32(supply_node,
-			"qcom,supply-ulp-load", &tmp);
-		if (rc)
-			pr_warn("%s: error reading ulp load. rc=%d\n",
-				__func__, rc);
-
-		mp->vreg_config[i].load[DSS_REG_MODE_ULP] = (!rc ? tmp :
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE]);
+		mp->vreg_config[i].disable_load = tmp;
 
 		/* pre-sleep */
 		rc = of_property_read_u32(supply_node,
@@ -398,14 +388,13 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 			mp->vreg_config[i].post_off_sleep = tmp;
 		}
 
-		pr_debug("%s: %s min=%d, max=%d, enable=%d, disable=%d, ulp=%d, preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
+		pr_debug("%s: %s min=%d, max=%d, enable=%d, disable=%d, preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
 			__func__,
 			mp->vreg_config[i].vreg_name,
 			mp->vreg_config[i].min_voltage,
 			mp->vreg_config[i].max_voltage,
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE]
-			mp->vreg_config[i].load[DSS_REG_MODE_DISABLE]
-			mp->vreg_config[i].load[DSS_REG_MODE_ULP]
+			mp->vreg_config[i].enable_load,
+			mp->vreg_config[i].disable_load,
 			mp->vreg_config[i].pre_on_sleep,
 			mp->vreg_config[i].post_on_sleep,
 			mp->vreg_config[i].pre_off_sleep,
diff --git a/drivers/video/msm/mdss/mdp3.c b/drivers/video/msm/mdss/mdp3.c
index 052c9964425..0b131abe9d4 100644
--- a/drivers/video/msm/mdss/mdp3.c
+++ b/drivers/video/msm/mdss/mdp3.c
@@ -442,16 +442,12 @@ static int mdp3_clk_update(u32 clk_idx, u32 enable)
 			mdp3_res->clock_ref_count[clk_idx]--;
 			return ret;
 		}
-		if (clk_idx == MDP3_CLK_MDP_CORE)
-			MDSS_XLOG(enable);
 		ret = clk_enable(clk);
 		if (ret)
 			pr_err("%s: clock enable failed %d\n", __func__,
 					clk_idx);
 	} else if (count == 0) {
 		pr_debug("clk=%d disable\n", clk_idx);
-		if (clk_idx == MDP3_CLK_MDP_CORE)
-			MDSS_XLOG(enable);
 		clk_disable(clk);
 		clk_unprepare(clk);
 		ret = 0;
@@ -1075,17 +1071,6 @@ u64 mdp3_get_panic_lut_cfg(u32 panel_width)
 	return panic_config;
 }
 
-int mdp3_enable_panic_ctrl(void)
-{
-	int rc = 0;
-
-	if (MDP3_REG_READ(MDP3_PANIC_ROBUST_CTRL) == 0) {
-		pr_err("%s: Enable Panic Control\n", __func__);
-		MDP3_REG_WRITE(MDP3_PANIC_ROBUST_CTRL, BIT(0));
-	}
-	return rc;
-}
-
 int mdp3_qos_remapper_setup(struct mdss_panel_data *panel)
 {
 	int rc = 0;
@@ -1139,7 +1124,7 @@ static int mdp3_res_init(void)
 
 	mdp3_res->ion_client = msm_ion_client_create(mdp3_res->pdev->name);
 	if (IS_ERR_OR_NULL(mdp3_res->ion_client)) {
-		pr_err("msm_ion_client_create() return error (%pK)\n",
+		pr_err("msm_ion_client_create() return error (%p)\n",
 				mdp3_res->ion_client);
 		mdp3_res->ion_client = NULL;
 		return -EINVAL;
@@ -1569,7 +1554,7 @@ void mdp3_unmap_iommu(struct ion_client *client, struct ion_handle *handle)
 	mutex_lock(&mdp3_res->iommu_lock);
 	meta = mdp3_iommu_meta_lookup(table);
 	if (!meta) {
-		WARN(1, "%s: buffer was never mapped for %pK\n", __func__,
+		WARN(1, "%s: buffer was never mapped for %p\n", __func__,
 				handle);
 		mutex_unlock(&mdp3_res->iommu_lock);
 		return;
@@ -1595,7 +1580,7 @@ static void mdp3_iommu_meta_add(struct mdp3_iommu_meta *meta)
 		} else if (meta->table > entry->table) {
 			p = &(*p)->rb_right;
 		} else {
-			pr_err("%s: handle %pK already exists\n", __func__,
+			pr_err("%s: handle %p already exists\n", __func__,
 				entry->handle);
 			BUG();
 		}
@@ -1658,7 +1643,7 @@ static int mdp3_iommu_map_iommu(struct mdp3_iommu_meta *meta,
 	ret = iommu_map_range(domain, meta->iova_addr + padding,
 			table->sgl, size, prot);
 	if (ret) {
-		pr_err("%s: could not map %pa in domain %pK\n",
+		pr_err("%s: could not map %pa in domain %p\n",
 			__func__, &meta->iova_addr, domain);
 			unmap_size = padding;
 		goto out2;
@@ -1781,12 +1766,12 @@ int mdp3_self_map_iommu(struct ion_client *client, struct ion_handle *handle,
 		}
 	} else {
 		if (iommu_meta->flags != iommu_flags) {
-			pr_err("%s: hndl %pK already mapped with diff flag\n",
+			pr_err("%s: hndl %p already mapped with diff flag\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
 		} else if (iommu_meta->mapped_size != iova_length) {
-			pr_err("%s: hndl %pK already mapped with diff len\n",
+			pr_err("%s: hndl %p already mapped with diff len\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
@@ -1820,7 +1805,7 @@ int mdp3_put_img(struct mdp3_img_data *data, int client)
 		fdput(data->srcp_f);
 		memset(&data->srcp_f, 0, sizeof(struct fd));
 	} else if (!IS_ERR_OR_NULL(data->srcp_dma_buf)) {
-		pr_debug("ion hdl = %pK buf=0x%pa\n", data->srcp_dma_buf,
+		pr_debug("ion hdl = %p buf=0x%pa\n", data->srcp_dma_buf,
 							&data->addr);
 		if (!iclient) {
 			pr_err("invalid ion client\n");
@@ -1923,7 +1908,7 @@ done:
 		data->addr += img->offset;
 		data->len -= img->offset;
 
-		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%lx\n",
+		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%lx\n",
 			img->memory_id, data->srcp_dma_buf,
 			&data->addr, data->len);
 
@@ -2209,11 +2194,11 @@ static int mdp3_is_display_on(struct mdss_panel_data *pdata)
 	}
 
 	mdp3_res->splash_mem_addr = MDP3_REG_READ(MDP3_REG_DMA_P_IBUF_ADDR);
-	
-	if ((pdata->panel_info.type == MIPI_CMD_PANEL) ||(!rc)) {
-		if (mdp3_clk_enable(0, 0))
-			pr_err("fail to turn off MDP core clks\n");
-	}
+
+	if (pdata->panel_info.type == MIPI_CMD_PANEL)
+	rc = mdp3_clk_enable(0, 0);
+	if (rc)
+		pr_err("fail to turn off MDP core clks\n");
 	return rc;
 }
 
@@ -2305,6 +2290,7 @@ static int mdp3_panel_register_done(struct mdss_panel_data *pdata)
 	if (pdata->panel_info.cont_splash_enabled == false)
 		mdp3_res->allow_iommu_update = true;
 
+	mdss_res->pdata = pdata;
 	return rc;
 }
 
@@ -2390,6 +2376,7 @@ static int mdp3_debug_init(struct platform_device *pdev)
 	mdss_res->mdss_util = mdp3_res->mdss_util;
 
 	mdata->debug_inf.debug_enable_clock = mdp3_debug_enable_clock;
+	mdata->mdp_rev = mdp3_res->mdp_rev;
 
 	rc = mdss_debugfs_init(mdata);
 	if (rc)
@@ -2633,18 +2620,15 @@ int mdp3_footswitch_ctrl(int enable)
 	int rc = 0;
 	int active_cnt = 0;
 
-	mutex_lock(&mdp3_res->fs_idle_pc_lock);
-	MDSS_XLOG(enable);
 	if (!mdp3_res->fs_ena && enable) {
 		rc = regulator_enable(mdp3_res->fs);
 		if (rc) {
 			pr_err("mdp footswitch ctrl enable failed\n");
-			mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 			return -EINVAL;
 		}
-		pr_debug("mdp footswitch ctrl enable success\n");
+			pr_debug("mdp footswitch ctrl enable success\n");
 		mdp3_enable_regulator(true);
-		mdp3_res->fs_ena = true;
+			mdp3_res->fs_ena = true;
 	} else if (!enable && mdp3_res->fs_ena) {
 		active_cnt = atomic_read(&mdp3_res->active_intf_cnt);
 		if (active_cnt != 0) {
@@ -2660,16 +2644,13 @@ int mdp3_footswitch_ctrl(int enable)
 		rc = regulator_disable(mdp3_res->fs);
 		if (rc) {
 			pr_err("mdp footswitch ctrl disable failed\n");
-			mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 			return -EINVAL;
 		}
 			mdp3_res->fs_ena = false;
-		pr_debug("mdp3 footswitch ctrl disable configured\n");
 	} else {
 		pr_debug("mdp3 footswitch ctrl already configured\n");
 	}
 
-	mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 	return rc;
 }
 
@@ -2691,8 +2672,9 @@ int mdp3_panel_get_intf_status(u32 disp_num, u32 intf_type)
 	rc = (status == 0x180000) || (status == 0x080000);
 
 	/* For Video mode panel do not disable clock */
-	if (!(status == 0x180000)) {
-		if (mdp3_clk_enable(0, 0))
+	if (status == 0x80000) {
+		rc = mdp3_clk_enable(0, 0);
+		if (rc)
 			pr_err("fail to turn off MDP core clks\n");
 	}
 	return rc;
@@ -2733,7 +2715,6 @@ static int mdp3_probe(struct platform_device *pdev)
 	pdev->id = 0;
 	mdp3_res->pdev = pdev;
 	mutex_init(&mdp3_res->res_mutex);
-	mutex_init(&mdp3_res->fs_idle_pc_lock);
 	spin_lock_init(&mdp3_res->irq_lock);
 	platform_set_drvdata(pdev, mdp3_res);
 	atomic_set(&mdp3_res->active_intf_cnt, 0);
@@ -2871,7 +2852,7 @@ static  int mdp3_resume_sub(void)
 static int mdp3_pm_suspend(struct device *dev)
 {
 	dev_dbg(dev, "Display pm suspend\n");
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
+
 	return mdp3_suspend_sub();
 }
 
@@ -2888,7 +2869,6 @@ static int mdp3_pm_resume(struct device *dev)
 	pm_runtime_set_suspended(dev);
 	pm_runtime_enable(dev);
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
 	return mdp3_resume_sub();
 }
 #endif
@@ -2898,7 +2878,6 @@ static int mdp3_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	pr_debug("Display suspend\n");
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
 	return mdp3_suspend_sub();
 }
 
@@ -2906,7 +2885,6 @@ static int mdp3_resume(struct platform_device *pdev)
 {
 	pr_debug("Display resume\n");
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
 	return mdp3_resume_sub();
 }
 #else
@@ -2927,7 +2905,6 @@ static int mdp3_runtime_resume(struct device *dev)
 	if (!mdp3_res->idle_pc)
 		device_for_each_child(dev, &device_on, mdss_fb_suspres_panel);
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
 	mdp3_footswitch_ctrl(1);
 
 	return 0;
@@ -2952,7 +2929,6 @@ static int mdp3_runtime_suspend(struct device *dev)
 		return -EBUSY;
 	}
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY);
 	mdp3_footswitch_ctrl(0);
 
 	/* do not suspend panels when going in to idle power collapse */
diff --git a/drivers/video/msm/mdss/mdp3.h b/drivers/video/msm/mdss/mdp3.h
index db7d3e1eae1..644c8fda8e1 100644
--- a/drivers/video/msm/mdss/mdp3.h
+++ b/drivers/video/msm/mdss/mdp3.h
@@ -168,7 +168,6 @@ struct mdp3_hw_resource {
 	bool allow_iommu_update;
 	struct ion_handle *ion_handle;
 	struct mutex iommu_lock;
-	struct mutex fs_idle_pc_lock;
 
 	struct mdp3_dma dma[MDP3_DMA_MAX];
 	struct mdp3_intf intf[MDP3_DMA_OUTPUT_SEL_MAX];
@@ -266,7 +265,6 @@ u64 mdp3_clk_round_off(u64 clk_rate);
 void mdp3_calc_dma_res(struct mdss_panel_info *panel_info, u64 *clk_rate,
 		u64 *ab, u64 *ib, uint32_t bpp);
 void mdp3_clear_irq(u32 interrupt_mask);
-int mdp3_enable_panic_ctrl(void);
 
 #define MDP3_REG_WRITE(addr, val) writel_relaxed(val, mdp3_res->mdp_base + addr)
 #define MDP3_REG_READ(addr) readl_relaxed(mdp3_res->mdp_base + addr)
diff --git a/drivers/video/msm/mdss/mdp3_ctrl.c b/drivers/video/msm/mdss/mdp3_ctrl.c
old mode 100755
new mode 100644
index 67f1c7b9e41..cfc0ab9eed4
--- a/drivers/video/msm/mdss/mdp3_ctrl.c
+++ b/drivers/video/msm/mdss/mdp3_ctrl.c
@@ -45,8 +45,6 @@ static void mdp3_ctrl_pp_resume(struct msm_fb_data_type *mfd);
 static int mdp3_ctrl_reset(struct msm_fb_data_type *mfd);
 static int mdp3_ctrl_get_pack_pattern(u32 imgType);
 
-int mdp3_wait_for_dma_done(struct mdp3_session_data *session);
-
 u32 mdp_lut_inverse16[MDP_LUT_SIZE] = {
 0, 65536, 32768, 21845, 16384, 13107, 10923, 9362, 8192, 7282, 6554, 5958,
 5461, 5041, 4681, 4369, 4096, 3855, 3641, 3449, 3277, 3121, 2979, 2849, 2731,
@@ -151,11 +149,10 @@ static void mdp3_dispatch_dma_done(struct work_struct *work)
 		return;
 
 	cnt = atomic_read(&session->dma_done_cnt);
-	MDSS_XLOG(cnt);
+
 	while (cnt > 0) {
 		mdp3_ctrl_notify(session, MDP_NOTIFY_FRAME_DONE);
 		atomic_dec(&session->dma_done_cnt);
-		mdp3_ctrl_notify(session, MDP_NOTIFY_FRAME_CTX_DONE);
 		cnt--;
 	}
 }
@@ -168,7 +165,6 @@ static void mdp3_dispatch_clk_off(struct work_struct *work)
 	int retry_count = 2;
 
 	pr_debug("%s\n", __func__);
-	MDSS_XLOG(XLOG_FUNC_ENTRY, __LINE__);
 	session = container_of(work, struct mdp3_session_data,
 				clk_off_work);
 	if (!session)
@@ -179,7 +175,6 @@ static void mdp3_dispatch_clk_off(struct work_struct *work)
 		atomic_read(&session->vsync_countdown) > 0) {
 		mutex_unlock(&session->lock);
 		pr_debug("%s: Ignoring clk shut down\n", __func__);
-		MDSS_XLOG(XLOG_FUNC_EXIT, __LINE__);
 		return;
 	}
 
@@ -208,7 +203,6 @@ retry_dma_done:
 	}
 	mdp3_ctrl_vsync_enable(session->mfd, 0);
 	mdp3_ctrl_clk_enable(session->mfd, 0);
-	MDSS_XLOG(XLOG_FUNC_EXIT, __LINE__);
 	mutex_unlock(&session->lock);
 }
 
@@ -216,7 +210,6 @@ void vsync_notify_handler(void *arg)
 {
 	struct mdp3_session_data *session = (struct mdp3_session_data *)arg;
 	session->vsync_time = ktime_get();
-	MDSS_XLOG(ktime_to_ms(session->vsync_time));
 	sysfs_notify_dirent(session->vsync_event_sd);
 }
 
@@ -232,11 +225,10 @@ void vsync_count_down(void *arg)
 {
 	struct mdp3_session_data *session = (struct mdp3_session_data *)arg;
 	/* We are counting down to turn off clocks */
-	if (atomic_read(&session->vsync_countdown) > 0) {
+	if (atomic_read(&session->vsync_countdown) > 0)
 		atomic_dec(&session->vsync_countdown);
-		if (atomic_read(&session->vsync_countdown) == 0)
-			schedule_work(&session->clk_off_work);
-	}
+	if (atomic_read(&session->vsync_countdown) == 0)
+		schedule_work(&session->clk_off_work);
 }
 
 void mdp3_ctrl_reset_countdown(struct mdp3_session_data *session,
@@ -715,11 +707,6 @@ static int mdp3_ctrl_dma_init(struct msm_fb_data_type *mfd,
 	te.hw_vsync_mode = panel_info->mipi.hw_vsync_mode;
 	te.tear_check_en = panel_info->te.tear_check_en;
 	te.sync_cfg_height = panel_info->te.sync_cfg_height;
-	/* For mdp3, max. value of CFG_HEIGHT is 0x7ff,
-	 * for mdp5, max. value of CFG_HEIGHT is 0xffff.
-	 */
-	if (te.sync_cfg_height > 0x7ff)
-		te.sync_cfg_height = 0x7ff;
 	te.vsync_init_val = panel_info->te.vsync_init_val;
 	te.sync_threshold_start = panel_info->te.sync_threshold_start;
 	te.sync_threshold_continue = panel_info->te.sync_threshold_continue;
@@ -770,7 +757,6 @@ static int mdp3_ctrl_on(struct msm_fb_data_type *mfd)
 	}
 	mutex_lock(&mdp3_session->lock);
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY, __LINE__, mfd->panel_power_state);
 	panel = mdp3_session->panel;
 	/* make sure DSI host is initialized properly */
 	if (panel) {
@@ -787,15 +773,12 @@ static int mdp3_ctrl_on(struct msm_fb_data_type *mfd)
 				MDSS_EVENT_UNBLANK, NULL);
 		rc |= panel->event_handler(panel,
 				MDSS_EVENT_PANEL_ON, NULL);
-		if (mdss_fb_is_power_on_ulp(mfd))
-			rc |= mdp3_enable_panic_ctrl();
 			mdp3_clk_enable(0, 0);
 		}
 	}
 
 	if (mdp3_session->status) {
 		pr_debug("fb%d is on already\n", mfd->index);
-		MDSS_XLOG(XLOG_FUNC_EXIT, __LINE__, mfd->panel_power_state);
 		goto end;
 	}
 
@@ -882,7 +865,6 @@ static int mdp3_ctrl_on(struct msm_fb_data_type *mfd)
 		mdp3_session->status = 1;
 
 	mdp3_ctrl_pp_resume(mfd);
-	MDSS_XLOG(XLOG_FUNC_EXIT, __LINE__, mfd->panel_power_state);
 on_error:
 	if (rc || (mdp3_res->idle_pc_enabled &&
 			(mfd->panel_info->type == MIPI_CMD_PANEL))) {
@@ -920,8 +902,6 @@ static int mdp3_ctrl_off(struct msm_fb_data_type *mfd)
 	 */
 	pm_runtime_get_sync(&mdp3_res->pdev->dev);
 
-	MDSS_XLOG(XLOG_FUNC_ENTRY, __LINE__, mdss_fb_is_power_on_ulp(mfd),
-		mfd->panel_power_state);
 	panel = mdp3_session->panel;
 	mutex_lock(&mdp3_session->lock);
 
@@ -1039,41 +1019,7 @@ static int mdp3_ctrl_off(struct msm_fb_data_type *mfd)
 
 	if (mdss_fb_is_power_on_ulp(mfd) &&
 		(mfd->panel.type == MIPI_CMD_PANEL)) {
-
-		pr_debug("Disable MDP3 clocks in ULP\n");
-		/*
-		 * Wait if DAM transfer in progress
-		 * else go ahead and turn off MDP clocks.
-		 */
-		if ( atomic_read(&mfd->kickoff_pending) ||
-		     atomic_read(&mfd->commits_pending)) {
-			rc = wait_event_timeout(mfd->kickoff_wait_q,
-				(!atomic_read(&mfd->kickoff_pending)),
-				msecs_to_jiffies(WAIT_DISP_OP_TIMEOUT));
-
-			if(!rc) {
-				pr_info("Wait for kickoff time out in ULP\n");
-				MDSS_XLOG(atomic_read(&mfd->kickoff_pending),
-					atomic_read(&mdp3_session->vsync_countdown),
-					rc);
-			}
-		}
-
-		/*
-		 * Enable MDP clk before DMA stop to handle cases where
-		 * ULP request is followd by dispatch clock off*/
-		if (!mdp3_session->clk_on)
-			mdp3_ctrl_clk_enable(mfd, 1);
-		/*
-		 * STOP DMA transfer first and signal vsync notification
-		 * Before releasing the resource in ULP state.
-		 */
-		rc = mdp3_session->dma->stop(mdp3_session->dma,
-					mdp3_session->intf);
-		if (rc)
-			pr_warn("fail to stop the MDP3 dma in ULP\n");
-		/* Wait to ensure TG to turn off */
-		msleep(20);
+		pr_debug("%s: Disable MDP3 clocks in ULP\n", __func__);
 		/*
 		 * Handle ULP request initiated from fb_pm_suspend.
 		 * For ULP panel power state disabling vsync and set
@@ -1085,7 +1031,6 @@ static int mdp3_ctrl_off(struct msm_fb_data_type *mfd)
 		mdp3_ctrl_clk_enable(mdp3_session->mfd, 0);
 	}
 off_error:
-	MDSS_XLOG(XLOG_FUNC_EXIT, __LINE__);
 	mutex_unlock(&mdp3_session->lock);
 	/* Release the last reference to the runtime device */
 	pm_runtime_put(&mdp3_res->pdev->dev);
@@ -1112,11 +1057,7 @@ static int mdp3_ctrl_reset(struct msm_fb_data_type *mfd)
 	panel = mdp3_session->panel;
 	mdp3_dma = mdp3_session->dma;
 	mutex_lock(&mdp3_session->lock);
-	pr_debug("mdp3_ctrl_reset idle_pc %s FS_EN %s\n",
-		mdp3_res->idle_pc? "True":"False",
-		mdp3_res->fs_ena ? "True":"False");
-	if (mdp3_res->idle_pc ||
-		(mdp3_res->fs_ena && !mdp3_session->in_splash_screen)) {    
+	if (mdp3_res->idle_pc) {
 		mdp3_clk_enable(1, 0);
 		mdp3_dynamic_clock_gating_ctrl(0);
 		mdp3_qos_remapper_setup(panel);
@@ -1125,7 +1066,7 @@ static int mdp3_ctrl_reset(struct msm_fb_data_type *mfd)
 	rc = mdp3_iommu_enable(MDP3_CLIENT_DMA_P);
 	if (rc) {
 		pr_err("fail to attach dma iommu\n");
-		if (mdp3_res->idle_pc || mdp3_res->fs_ena)
+		if (mdp3_res->idle_pc)
 			mdp3_clk_enable(0, 0);
 		goto reset_error;
 	}
@@ -1244,26 +1185,16 @@ static int mdp3_overlay_queue_buffer(struct msm_fb_data_type *mfd,
 					struct msmfb_overlay_data *req)
 {
 	int rc;
-	bool is_panel_type_cmd = false;
 	struct mdp3_session_data *mdp3_session = mfd->mdp.private1;
 	struct msmfb_data *img = &req->data;
 	struct mdp3_img_data data;
 	struct mdp3_dma *dma = mdp3_session->dma;
 
 	memset(&data, 0, sizeof(struct mdp3_img_data));
-	if (mfd->panel.type == MIPI_CMD_PANEL)
-		is_panel_type_cmd = true;
-	if (is_panel_type_cmd) {
-		rc = mdp3_iommu_enable(MDP3_CLIENT_DMA_P);
-		if (rc) {
-			pr_err("fail to enable iommu\n");
-			return rc;
-		}
-	}
 	rc = mdp3_get_img(img, &data, MDP3_CLIENT_DMA_P);
 	if (rc) {
 		pr_err("fail to get overlay buffer\n");
-		goto err;
+		return rc;
 	}
 
 	if (data.len < dma->source_config.stride * dma->source_config.height) {
@@ -1271,20 +1202,16 @@ static int mdp3_overlay_queue_buffer(struct msm_fb_data_type *mfd,
 			data.len, (dma->source_config.stride *
 			dma->source_config.height));
 		mdp3_put_img(&data, MDP3_CLIENT_DMA_P);
-		rc = -EINVAL;
-		goto err;
+		return -EINVAL;
 	}
+
 	rc = mdp3_bufq_push(&mdp3_session->bufq_in, &data);
 	if (rc) {
 		pr_err("fail to queue the overlay buffer, buffer drop\n");
 		mdp3_put_img(&data, MDP3_CLIENT_DMA_P);
-		goto err;
+		return rc;
 	}
-	rc = 0;
-err:
-	if (is_panel_type_cmd)
-		mdp3_iommu_disable(MDP3_CLIENT_DMA_P);
-	return rc;
+	return 0;
 }
 
 static int mdp3_overlay_play(struct msm_fb_data_type *mfd,
@@ -1338,7 +1265,6 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 	int rc = 0;
 	static bool splash_done;
 	struct mdss_panel_data *panel;
-	int prev_bl;
 
 	if (!mfd || !mfd->mdp.private1)
 		return -EINVAL;
@@ -1353,8 +1279,22 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 		return -EPERM;
 	}
 
+	if (panel_info->partial_update_enabled &&
+		is_roi_valid(mdp3_session->dma->source_config, cmt_data->l_roi)
+		&& update_roi(mdp3_session->dma->roi, cmt_data->l_roi)) {
+			mdp3_session->dma->roi.x = cmt_data->l_roi.x;
+			mdp3_session->dma->roi.y = cmt_data->l_roi.y;
+			mdp3_session->dma->roi.w = cmt_data->l_roi.w;
+			mdp3_session->dma->roi.h = cmt_data->l_roi.h;
+			mdp3_session->dma->update_src_cfg = true;
+			pr_debug("%s: ROI: x=%d y=%d w=%d h=%d\n", __func__,
+				mdp3_session->dma->roi.x,
+				mdp3_session->dma->roi.y,
+				mdp3_session->dma->roi.w,
+				mdp3_session->dma->roi.h);
+	}
+
 	panel = mdp3_session->panel;
-	mutex_lock(&mdp3_res->fs_idle_pc_lock);
 	if (mdp3_session->in_splash_screen ||
 		mdp3_res->idle_pc) {
 		pr_debug("%s: reset- in_splash = %d, idle_pc = %d", __func__,
@@ -1362,14 +1302,9 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 		rc = mdp3_ctrl_reset(mfd);
 		if (rc) {
 			pr_err("fail to reset display\n");
-			mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 			return -EINVAL;
 		}
-		if ((mdp3_session->dma->roi.x || mdp3_session->dma->roi.y) &&
-			panel_info->partial_update_enabled)
-			mdp3_session->dma->update_src_cfg = true;
 	}
-	mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 
 	mutex_lock(&mdp3_session->lock);
 
@@ -1379,21 +1314,6 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 		return -EPERM;
 	}
 
-	if (panel_info->partial_update_enabled &&
-		is_roi_valid(mdp3_session->dma->source_config, cmt_data->l_roi)
-		&& update_roi(mdp3_session->dma->roi, cmt_data->l_roi)) {
-			mdp3_session->dma->roi.x = cmt_data->l_roi.x;
-			mdp3_session->dma->roi.y = cmt_data->l_roi.y;
-			mdp3_session->dma->roi.w = cmt_data->l_roi.w;
-			mdp3_session->dma->roi.h = cmt_data->l_roi.h;
-			mdp3_session->dma->update_src_cfg = true;
-			pr_debug("%s: ROI: x=%d y=%d w=%d h=%d\n", __func__,
-				mdp3_session->dma->roi.x,
-				mdp3_session->dma->roi.y,
-				mdp3_session->dma->roi.w,
-				mdp3_session->dma->roi.h);
-	}
-
 	mdp3_ctrl_notify(mdp3_session, MDP_NOTIFY_FRAME_BEGIN);
 	data = mdp3_bufq_pop(&mdp3_session->bufq_in);
 	if (data) {
@@ -1407,14 +1327,11 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 			panel->panel_info.roi.h = mdp3_session->dma->roi.h;
 			rc = mdp3_session->dma->update(mdp3_session->dma,
 					(void *)(int)data->addr,
-					mdp3_session->intf,
-					mdp3_session->first_commit,
-					(void *)panel);
+					mdp3_session->intf, (void *)panel);
 		} else {
 			rc = mdp3_session->dma->update(mdp3_session->dma,
 					(void *)(int)data->addr,
-					mdp3_session->intf,
-					mdp3_session->first_commit, NULL);
+					mdp3_session->intf, NULL);
 		}
 		/* This is for the previous frame */
 		if (rc < 0) {
@@ -1425,8 +1342,6 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 						MDP3_DMA_OUTPUT_SEL_DSI_VIDEO) {
 				mdp3_ctrl_notify(mdp3_session,
 					MDP_NOTIFY_FRAME_DONE);
-				mdp3_ctrl_notify(mdp3_session,
-					MDP_NOTIFY_FRAME_CTX_DONE);
 			}
 		}
 		mdp3_session->dma_active = 1;
@@ -1444,11 +1359,11 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 
 	if (mdp3_session->first_commit) {
 		/*wait to ensure frame is sent to panel*/
-		rc = mdp3_wait_for_dma_done(mdp3_session);
-
-		if(rc)
-			msleep((1000 / panel_info->mipi.frame_rate) + 1);
-
+		if (panel_info->mipi.init_delay)
+			msleep(((1000 / panel_info->mipi.frame_rate) + 1) *
+					panel_info->mipi.init_delay);
+		else
+			msleep(1000 / panel_info->mipi.frame_rate);
 		mdp3_session->first_commit = false;
 		if (panel)
 			rc |= panel->event_handler(panel,
@@ -1456,17 +1371,11 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 	}
 
 	mdp3_session->vsync_before_commit = 0;
-	prev_bl = mfd->bl_level;
 	if (!splash_done || mdp3_session->esd_recovery == true) {
-		if (panel && panel->set_backlight) {
-			if (mdp3_session->esd_recovery == true && prev_bl > 0)
-				panel->set_backlight(panel, prev_bl);
-			else
-				panel->set_backlight(panel, panel->panel_info.bl_max);
-		}
+		if (panel && panel->set_backlight)
+			panel->set_backlight(panel, panel->panel_info.bl_max);
 		splash_done = true;
 		mdp3_session->esd_recovery = false;
-
 	}
 
 	/* start vsync tick countdown for cmd mode if vsync isn't enabled */
@@ -1528,7 +1437,6 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 	if (!mdp3_session || !mdp3_session->dma)
 		return;
 
-	mutex_lock(&mdp3_res->fs_idle_pc_lock);
 	if (mdp3_session->in_splash_screen ||
 		mdp3_res->idle_pc) {
 		pr_debug("%s: reset- in_splash = %d, idle_pc = %d", __func__,
@@ -1536,11 +1444,9 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 		rc = mdp3_ctrl_reset(mfd);
 		if (rc) {
 			pr_err("fail to reset display\n");
-			mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 			return;
 		}
 	}
-	mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 
 	mutex_lock(&mdp3_session->lock);
 
@@ -1571,8 +1477,8 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 				goto pan_error;
 		}
 		rc = mdp3_session->dma->update(mdp3_session->dma,
-				(void *)(int)(mfd->iova + offset), mdp3_session->intf,
-				mdp3_session->first_commit, NULL);
+				(void *)(int)(mfd->iova + offset),
+				mdp3_session->intf, NULL);
 		/* This is for the previous frame */
 		if (rc < 0) {
 			mdp3_ctrl_notify(mdp3_session,
@@ -1582,8 +1488,6 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 				MDP3_DMA_OUTPUT_SEL_DSI_VIDEO) {
 				mdp3_ctrl_notify(mdp3_session,
 					MDP_NOTIFY_FRAME_DONE);
-				mdp3_ctrl_notify(mdp3_session,
-					MDP_NOTIFY_FRAME_CTX_DONE);
 			}
 		}
 		mdp3_session->dma_active = 1;
@@ -2608,21 +2512,17 @@ static int mdp3_ctrl_ioctl_handler(struct msm_fb_data_type *mfd,
 		}
 		break;
 	case MSMFB_ASYNC_BLIT:
-		mutex_lock(&mdp3_res->fs_idle_pc_lock);
 		if (mdp3_session->in_splash_screen || mdp3_res->idle_pc) {
 			pr_debug("%s: reset- in_splash = %d, idle_pc = %d",
 				__func__, mdp3_session->in_splash_screen,
 				mdp3_res->idle_pc);
 			mdp3_ctrl_reset(mfd);
 		}
-		mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 		rc = mdp3_ctrl_async_blit_req(mfd, argp);
 		break;
 	case MSMFB_BLIT:
-		mutex_lock(&mdp3_res->fs_idle_pc_lock);
 		if (mdp3_session->in_splash_screen)
 			mdp3_ctrl_reset(mfd);
-		mutex_unlock(&mdp3_res->fs_idle_pc_lock);
 		rc = mdp3_ctrl_blit_req(mfd, argp);
 		break;
 	case MSMFB_METADATA_GET:
@@ -2669,7 +2569,7 @@ static int mdp3_ctrl_ioctl_handler(struct msm_fb_data_type *mfd,
 		break;
 	case MSMFB_OVERLAY_PLAY:
 		rc = copy_from_user(&ov_data, argp, sizeof(ov_data));
-		if (!rc && !mfd->ulps_fmode)
+		if (!rc)
 			rc = mdp3_overlay_play(mfd, &ov_data);
 		if (rc)
 			pr_err("OVERLAY_PLAY failed (%d)\n", rc);
@@ -2751,6 +2651,7 @@ int mdp3_ctrl_init(struct msm_fb_data_type *mfd)
 	u32 intf_type = MDP3_DMA_OUTPUT_SEL_DSI_VIDEO;
 	int rc;
 	int splash_mismatch = 0;
+
 	pr_info("mdp3_ctrl_init\n");
 	rc = mdp3_parse_dt_splash(mfd);
 	if (rc)
@@ -2816,7 +2717,6 @@ int mdp3_ctrl_init(struct msm_fb_data_type *mfd)
 	mdp3_session->vsync_timer.data = (u32)mdp3_session;
 	mdp3_session->vsync_period = 1000 / mfd->panel_info->mipi.frame_rate;
 	mfd->mdp.private1 = mdp3_session;
-	mfd->wait_for_kickoff = true;
 	init_completion(&mdp3_session->dma_completion);
 	if (intf_type != MDP3_DMA_OUTPUT_SEL_DSI_VIDEO)
 		mdp3_session->wait_for_dma_done = mdp3_wait_for_dma_done;
diff --git a/drivers/video/msm/mdss/mdp3_dma.c b/drivers/video/msm/mdss/mdp3_dma.c
index b6f19230d36..5e65c15e3dc 100644
--- a/drivers/video/msm/mdss/mdp3_dma.c
+++ b/drivers/video/msm/mdss/mdp3_dma.c
@@ -270,7 +270,7 @@ int mdp3_dma_sync_config(struct mdp3_dma *dma,
 
 	vsync_clk_speed_hz = MDP_VSYNC_CLK_RATE;
 
-	cfg = te->sync_cfg_height << VSYNC_TOTAL_LINES_SHIFT;
+	cfg = total_lines << VSYNC_TOTAL_LINES_SHIFT;
 	total_lines *= te->frame_rate;
 
 	vclks_line = (total_lines) ? vsync_clk_speed_hz / total_lines : 0;
@@ -647,8 +647,7 @@ int dma_bpp(int format)
 }
 
 static int mdp3_dmap_update(struct mdp3_dma *dma, void *buf,
-				struct mdp3_intf *intf, int first_commit,
-				void *data)
+				struct mdp3_intf *intf, void *data)
 {
 	unsigned long flag;
 	int cb_type = MDP3_DMA_CALLBACK_TYPE_VSYNC;
@@ -661,7 +660,7 @@ static int mdp3_dmap_update(struct mdp3_dma *dma, void *buf,
 
 	if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD) {
 		cb_type = MDP3_DMA_CALLBACK_TYPE_DMA_DONE;
-		if ((intf->active) && !(first_commit)) {
+		if (intf->active) {
 			ATRACE_BEGIN("mdp3_wait_for_dma_comp");
 retry_dma_done:
 			rc = wait_for_completion_timeout(&dma->dma_comp,
@@ -747,8 +746,7 @@ retry_vsync:
 }
 
 static int mdp3_dmas_update(struct mdp3_dma *dma, void *buf,
-				struct mdp3_intf *intf, int first_commit,
-				void *data)
+				struct mdp3_intf *intf, void *data)
 {
 	unsigned long flag;
 	int cb_type = MDP3_DMA_CALLBACK_TYPE_VSYNC;
diff --git a/drivers/video/msm/mdss/mdp3_dma.h b/drivers/video/msm/mdss/mdp3_dma.h
index e84c0b7f929..fb719f6ba62 100644
--- a/drivers/video/msm/mdss/mdp3_dma.h
+++ b/drivers/video/msm/mdss/mdp3_dma.h
@@ -316,8 +316,7 @@ struct mdp3_dma {
 			struct fb_cmap *cmap);
 
 	int (*update)(struct mdp3_dma *dma,
-			void *buf, struct mdp3_intf *intf, int first_commit,
-			void *data);
+			void *buf, struct mdp3_intf *intf, void *data);
 
 	int (*update_cursor)(struct mdp3_dma *dma, int x, int y);
 
diff --git a/drivers/video/msm/mdss/mdp3_ppp.c b/drivers/video/msm/mdss/mdp3_ppp.c
index a4e93f88dc4..d2285d76b64 100644
--- a/drivers/video/msm/mdss/mdp3_ppp.c
+++ b/drivers/video/msm/mdss/mdp3_ppp.c
@@ -101,9 +101,7 @@ struct ppp_status {
 	struct mutex config_ppp_mutex; /* Only one client configure register */
 	struct msm_fb_data_type *mfd;
 
-	struct kthread_work blit_work;
-	struct kthread_worker kworker;
-	struct task_struct *blit_thread;
+	struct work_struct blit_work;
 	struct blit_req_queue req_q;
 
 	struct sw_sync_timeline *timeline;
@@ -1205,7 +1203,6 @@ void mdp3_ppp_wait_for_fence(struct blit_req_list *req)
 void mdp3_ppp_signal_timeline(struct blit_req_list *req)
 {
 	sw_sync_timeline_inc(ppp_stat->timeline, 1);
-	MDSS_XLOG(ppp_stat->timeline->value, ppp_stat->timeline_value);
 	req->last_rel_fence = req->cur_rel_fence;
 	req->cur_rel_fence = 0;
 }
@@ -1262,7 +1259,6 @@ static int mdp3_ppp_handle_buf_sync(struct blit_req_list *req,
 
 	req->cur_rel_sync_pt = sw_sync_pt_create(ppp_stat->timeline,
 			ppp_stat->timeline_value++);
-	MDSS_XLOG(ppp_stat->timeline_value);
 	if (req->cur_rel_sync_pt == NULL) {
 		pr_err("%s: cannot create sync point\n", __func__);
 		ret = -ENOMEM;
@@ -1486,7 +1482,7 @@ static bool is_blit_optimization_possible(struct blit_req_list *req, int indx)
 	return status;
 }
 
-static void mdp3_ppp_blit_handler(struct kthread_work *work)
+static void mdp3_ppp_blit_wq_handler(struct work_struct *work)
 {
 	struct msm_fb_data_type *mfd = ppp_stat->mfd;
 	struct blit_req_list *req;
@@ -1654,7 +1650,7 @@ int mdp3_ppp_parse_req(void __user *p,
 
 	mdp3_ppp_req_push(req_q, req);
 	mutex_unlock(&ppp_stat->req_mutex);
-	queue_kthread_work(&ppp_stat->kworker, &ppp_stat->blit_work);
+	schedule_work(&ppp_stat->blit_work);
 	if (!async) {
 		/* wait for release fence */
 		rc = sync_fence_wait(fence,
@@ -1681,10 +1677,7 @@ parse_err_1:
 
 int mdp3_ppp_res_init(struct msm_fb_data_type *mfd)
 {
-	int rc;
-	struct sched_param param = {.sched_priority = 16};
 	const char timeline_name[] = "mdp3_ppp";
-
 	ppp_stat = kzalloc(sizeof(struct ppp_status), GFP_KERNEL);
 	if (!ppp_stat) {
 		pr_err("%s: kzalloc failed\n", __func__);
@@ -1700,21 +1693,7 @@ int mdp3_ppp_res_init(struct msm_fb_data_type *mfd)
 		ppp_stat->timeline_value = 1;
 	}
 
-	init_kthread_worker(&ppp_stat->kworker);
-	init_kthread_work(&ppp_stat->blit_work, mdp3_ppp_blit_handler);
-	ppp_stat->blit_thread = kthread_run(kthread_worker_fn,
-					&ppp_stat->kworker,
-					"mdp3_ppp");
-
-	if (IS_ERR(ppp_stat->blit_thread)) {
-		rc = PTR_ERR(ppp_stat->blit_thread);
-		pr_err("ERROR: unable to start ppp blit thread, err = %d\n", rc);
-		ppp_stat->blit_thread = NULL;
-		return rc;
-	}
-	if (sched_setscheduler(ppp_stat->blit_thread, SCHED_FIFO, &param))
-		pr_warn("set priority failed for mdp3 blit thread\n");
-
+	INIT_WORK(&ppp_stat->blit_work, mdp3_ppp_blit_wq_handler);
 	INIT_WORK(&ppp_stat->free_bw_work, mdp3_free_bw_wq_handler);
 	init_completion(&ppp_stat->pop_q_comp);
 	mutex_init(&ppp_stat->req_mutex);
diff --git a/drivers/video/msm/mdss/mdp3_ppp_hwio.c b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
index 9310737f7c4..e14abd0da44 100644
--- a/drivers/video/msm/mdss/mdp3_ppp_hwio.c
+++ b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
@@ -23,7 +23,6 @@
 #include "mdss_fb.h"
 #include "mdp3_ppp.h"
 #include "mdp3_hwio.h"
-#include "mdss_debug.h"
 
 /* SHIM Q Factor */
 #define PHI_Q_FACTOR          29
@@ -1309,7 +1308,7 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 	pr_debug("ROI(x %d,y %d,w %d, h %d) ",
 		blit_op->src.roi.x, blit_op->src.roi.y,
 		blit_op->src.roi.width, blit_op->src.roi.height);
-	pr_debug("Addr_P0 %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
+	pr_debug("Addr_P0 %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
 		blit_op->src.p0, blit_op->src.stride0,
 		blit_op->src.p1, blit_op->src.stride1);
 
@@ -1321,7 +1320,7 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 		pr_debug("ROI(x %d,y %d, w  %d, h %d) ",
 			blit_op->bg.roi.x, blit_op->bg.roi.y,
 			blit_op->bg.roi.width, blit_op->bg.roi.height);
-		pr_debug("Addr %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
+		pr_debug("Addr %p, Stride S0 %d	Addr_P1 %p, Stride S1 %d\n",
 			blit_op->bg.p0,	blit_op->bg.stride0,
 			blit_op->bg.p1,	blit_op->bg.stride1);
 	}
@@ -1332,16 +1331,12 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 	pr_debug("ROI(x %d,y %d, w %d, h %d) ",
 		blit_op->dst.roi.x, blit_op->dst.roi.y,
 		blit_op->dst.roi.width, blit_op->dst.roi.height);
-	pr_debug("Addr %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
+	pr_debug("Addr %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
 		blit_op->dst.p0, blit_op->dst.stride0,
 		blit_op->dst.p1, blit_op->dst.stride1);
 
 	PPP_WRITEL(ppp_operation_reg, MDP3_PPP_OP_MODE);
 	mb();
-	MDSS_XLOG(ppp_operation_reg, blit_op->src.roi.x, blit_op->src.roi.y,
-		blit_op->src.roi.width, blit_op->src.roi.height);
-	 MDSS_XLOG(blit_op->dst.roi.x, blit_op->dst.roi.y,
-		blit_op->dst.roi.width, blit_op->dst.roi.height);
 	return 0;
 }
 
diff --git a/drivers/video/msm/mdss/mdss.h b/drivers/video/msm/mdss/mdss.h
index dc3713bae9f..8d4fd831266 100644
--- a/drivers/video/msm/mdss/mdss.h
+++ b/drivers/video/msm/mdss/mdss.h
@@ -242,6 +242,7 @@ struct mdss_data_type {
 	bool en_svs_high;
 	u32 max_mdp_clk_rate;
 	struct mdss_util_intf *mdss_util;
+	struct mdss_panel_data *pdata;
 
 	struct platform_device *pdev;
 	struct dss_io_data mdss_io;
diff --git a/drivers/video/msm/mdss/mdss_compat_utils.c b/drivers/video/msm/mdss/mdss_compat_utils.c
index 7159d911486..e883f045967 100644
--- a/drivers/video/msm/mdss/mdss_compat_utils.c
+++ b/drivers/video/msm/mdss/mdss_compat_utils.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  * Copyright (C) 1994 Martin Schaller
  *
  * 2001 - Documented with DocBook
@@ -150,7 +150,7 @@ static struct mdp_input_layer32 *__create_layer_list32(
 			compat_ptr(commit32->commit_v1.input_layers),
 			sizeof(struct mdp_input_layer32) * layer_count);
 	if (ret) {
-		pr_err("layer list32 copy from user failed, ptr %pK\n",
+		pr_err("layer list32 copy from user failed, ptr %p\n",
 			compat_ptr(commit32->commit_v1.input_layers));
 		kfree(layer_list32);
 		ret = -EFAULT;
@@ -182,7 +182,7 @@ static int __copy_scale_params(struct mdp_input_layer *layer,
 			sizeof(struct mdp_scale_data));
 	if (ret) {
 		kfree(scale);
-		pr_err("scale param copy from user failed, ptr %pK\n",
+		pr_err("scale param copy from user failed, ptr %p\n",
 			compat_ptr(layer32->scale));
 		ret = -EFAULT;
 	} else {
@@ -307,7 +307,7 @@ static int __compat_atomic_commit(struct fb_info *info, unsigned int cmd,
 	ret = copy_from_user(&commit32, (void __user *)argp,
 		sizeof(struct mdp_layer_commit32));
 	if (ret) {
-		pr_err("%s:copy_from_user failed, ptr %pK\n", __func__,
+		pr_err("%s:copy_from_user failed, ptr %p\n", __func__,
 			(void __user *)argp);
 		ret = -EFAULT;
 		return ret;
@@ -325,7 +325,7 @@ static int __compat_atomic_commit(struct fb_info *info, unsigned int cmd,
 				compat_ptr(commit32.commit_v1.output_layer),
 				buffer_size);
 		if (ret) {
-			pr_err("fail to copy output layer from user, ptr %pK\n",
+			pr_err("fail to copy output layer from user, ptr %p\n",
 				compat_ptr(commit32.commit_v1.output_layer));
 			ret = -EFAULT;
 			goto layer_list_err;
@@ -846,7 +846,6 @@ static int __from_user_pcc_coeff_v17(
 		return -EFAULT;
 	}
 
-	memset(&pcc_cfg_payload, 0, sizeof(pcc_cfg_payload));
 	pcc_cfg_payload.r.b = pcc_cfg_payload32.r.b;
 	pcc_cfg_payload.r.g = pcc_cfg_payload32.r.g;
 	pcc_cfg_payload.r.c = pcc_cfg_payload32.r.c;
@@ -935,7 +934,6 @@ static int __to_user_pcc_coeff_v1_7(
 	struct mdp_pcc_data_v1_7_32 pcc_cfg_payload32;
 	struct mdp_pcc_data_v1_7 pcc_cfg_payload;
 
-	memset(&pcc_cfg_payload32, 0, sizeof(pcc_cfg_payload32));
 	if (copy_from_user(&pcc_cfg_payload,
 			   pcc_cfg->cfg_payload,
 			   sizeof(struct mdp_pcc_data_v1_7))) {
@@ -1129,8 +1127,6 @@ static int __from_user_igc_lut_data_v17(
 		pr_err("failed to copy payload from user for igc\n");
 		return -EFAULT;
 	}
-
-	memset(&igc_cfg_payload, 0, sizeof(igc_cfg_payload));
 	igc_cfg_payload.c0_c1_data = compat_ptr(igc_cfg_payload_32.c0_c1_data);
 	igc_cfg_payload.c2_data = compat_ptr(igc_cfg_payload_32.c2_data);
 	igc_cfg_payload.len = igc_cfg_payload_32.len;
@@ -1265,7 +1261,6 @@ static int __from_user_pgc_lut_data_v1_7(
 		pr_err("failed to copy from user the pgc32 payload\n");
 		return -EFAULT;
 	}
-	memset(&pgc_cfg_payload, 0, sizeof(pgc_cfg_payload));
 	pgc_cfg_payload.c0_data = compat_ptr(pgc_cfg_payload_32.c0_data);
 	pgc_cfg_payload.c1_data = compat_ptr(pgc_cfg_payload_32.c1_data);
 	pgc_cfg_payload.c2_data = compat_ptr(pgc_cfg_payload_32.c2_data);
@@ -1475,7 +1470,6 @@ static int __from_user_hist_lut_data_v1_7(
 		return -EFAULT;
 	}
 
-	memset(&hist_lut_cfg_payload, 0, sizeof(hist_lut_cfg_payload));
 	hist_lut_cfg_payload.len = hist_lut_cfg_payload32.len;
 	hist_lut_cfg_payload.data = compat_ptr(hist_lut_cfg_payload32.data);
 
@@ -2030,7 +2024,6 @@ static int __from_user_pa_data_v1_7(
 		return -EFAULT;
 	}
 
-	memset(&pa_cfg_payload, 0, sizeof(pa_cfg_payload));
 	pa_cfg_payload.mode = pa_cfg_payload32.mode;
 	pa_cfg_payload.global_hue_adj = pa_cfg_payload32.global_hue_adj;
 	pa_cfg_payload.global_sat_adj = pa_cfg_payload32.global_sat_adj;
@@ -2131,7 +2124,6 @@ static int __to_user_pa_data_v1_7(
 	struct mdp_pa_data_v1_7_32 pa_cfg_payload32;
 	struct mdp_pa_data_v1_7 pa_cfg_payload;
 
-	memset(&pa_cfg_payload32, 0, sizeof(pa_cfg_payload32));
 	if (copy_from_user(&pa_cfg_payload,
 			pa_v2_cfg->cfg_payload,
 			sizeof(pa_cfg_payload))) {
@@ -2288,8 +2280,6 @@ static int __from_user_gamut_cfg_data_v17(
 		pr_err("failed to copy the gamut payload from userspace\n");
 		return -EFAULT;
 	}
-
-	memset(&gamut_cfg_payload, 0, sizeof(gamut_cfg_payload));
 	gamut_cfg_payload.mode = gamut_cfg_payload32.mode;
 	for (i = 0; i < MDP_GAMUT_TABLE_NUM_V1_7; i++) {
 		gamut_cfg_payload.tbl_size[i] =
@@ -3428,7 +3418,7 @@ static int __copy_layer_igc_lut_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_igc_lut_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, IGC cfg payload = %pK\n",
+		pr_err("copy from user failed, IGC cfg payload = %p\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3503,7 +3493,7 @@ static int __copy_layer_hist_lut_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_hist_lut_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, hist lut cfg_payload = %pK\n",
+		pr_err("copy from user failed, hist lut cfg_payload = %p\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3575,7 +3565,7 @@ static int __copy_layer_pa_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_pa_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, pa cfg_payload = %pK\n",
+		pr_err("copy from user failed, pa cfg_payload = %p\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3717,7 +3707,7 @@ static int __copy_layer_pp_info_pcc_params(
 			compat_ptr(pp_info32->pcc_cfg_data.cfg_payload),
 			sizeof(struct mdp_pcc_data_v1_7));
 		if (ret) {
-			pr_err("compat copy of PCC cfg payload failed, ptr %pK\n",
+			pr_err("compat copy of PCC cfg payload failed, ptr %p\n",
 				compat_ptr(
 				pp_info32->pcc_cfg_data.cfg_payload));
 			ret = -EFAULT;
@@ -3751,7 +3741,7 @@ static int __copy_layer_pp_info_params(struct mdp_input_layer *layer,
 			compat_ptr(layer32->pp_info),
 			sizeof(struct mdp_overlay_pp_params32));
 	if (ret) {
-		pr_err("pp info copy from user failed, pp_info %pK\n",
+		pr_err("pp info copy from user failed, pp_info %p\n",
 			compat_ptr(layer32->pp_info));
 		ret = -EFAULT;
 		goto exit;
diff --git a/drivers/video/msm/mdss/mdss_debug.c b/drivers/video/msm/mdss/mdss_debug.c
index a2912e6f87f..a95745fceed 100644
--- a/drivers/video/msm/mdss/mdss_debug.c
+++ b/drivers/video/msm/mdss/mdss_debug.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -38,9 +38,8 @@
 #define PANEL_TX_MAX_BUF 256
 #define PANEL_CMD_MIN_TX_COUNT 2
 #define PANEL_DATA_NODE_LEN 80
-
-/* Hex number + whitespace */
-#define NEXT_VALUE_OFFSET 3
+/* MDP3 HW Version */
+#define MDP_CORE_HW_VERSION 0x03050306
 
 static char panel_reg[2] = {DEFAULT_READ_PANEL_POWER_MODE_REG, 0x00};
 
@@ -130,12 +129,13 @@ static ssize_t panel_debug_base_reg_write(struct file *file,
 	struct mdss_debug_base *dbg = file->private_data;
 	char buf[PANEL_TX_MAX_BUF] = {0x0};
 	char reg[PANEL_TX_MAX_BUF] = {0x0};
-	u32 len = 0, value = 0;
+	u32 len = 0, step = 0, value = 0;
 	char *bufp;
 
 	struct mdss_data_type *mdata = mdss_res;
-	struct mdss_mdp_ctl *ctl;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata;
+	struct mdss_mdp_ctl *ctl = mdata->ctl_off + 0;
+	struct mdss_panel_data *panel_data = NULL;
+	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 	struct dsi_cmd_desc dsi_write_cmd = {
 		{0/*data type*/, 1, 0, 0, 0, 0/* len */}, reg};
 	struct dcs_cmd_req cmdreq;
@@ -150,24 +150,25 @@ static ssize_t panel_debug_base_reg_write(struct file *file,
 	if (copy_from_user(buf, user_buf, count))
 		return -EFAULT;
 
+	if ((mdata->mdp_rev <= MDSS_MDP_HW_REV_105) ||
+			(mdata->mdp_rev == MDP_CORE_HW_VERSION))
+		panel_data = mdss_res->pdata;
+	else
+		panel_data = ctl->panel_data;
+
+	ctrl_pdata = container_of(panel_data,
+			struct mdss_dsi_ctrl_pdata, panel_data);
+
 	buf[count] = 0;	/* end of string */
 
 	bufp = buf;
-	/* End of a hex value in given string */
-	bufp[NEXT_VALUE_OFFSET - 1] = 0;
-	while (kstrtouint(bufp, 16, &value) == 0) {
+	while (sscanf(bufp, "%x%n", &value, &step) > 0) {
 		reg[len++] = value;
 		if (len >= PANEL_TX_MAX_BUF) {
 			pr_err("wrong input reg len\n");
 			return -EFAULT;
 		}
-		bufp += NEXT_VALUE_OFFSET;
-		if ((bufp >= (buf + count)) || (bufp < buf)) {
-			pr_warn("%s,buffer out-of-bounds\n", __func__);
-			break;
-		}
-		/* End of a hex value in given string */
-		bufp[NEXT_VALUE_OFFSET - 1] = 0;
+		bufp += step;
 	}
 	if (len < PANEL_CMD_MIN_TX_COUNT) {
 		pr_err("wrong input reg len\n");
@@ -208,10 +209,8 @@ static ssize_t panel_debug_base_reg_read(struct file *file,
 	char *panel_reg_buf, *rx_buf;
 	struct mdss_data_type *mdata = mdss_res;
 	struct mdss_mdp_ctl *ctl = mdata->ctl_off + 0;
-	struct mdss_panel_data *panel_data = ctl->panel_data;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = container_of(panel_data,
-					struct mdss_dsi_ctrl_pdata, panel_data);
-	int rc = -EFAULT;
+	struct mdss_panel_data *panel_data = NULL;
+	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 
 	if (!dbg)
 		return -ENODEV;
@@ -230,14 +229,23 @@ static ssize_t panel_debug_base_reg_read(struct file *file,
 
 	if (!rx_buf || !panel_reg_buf) {
 		pr_err("not enough memory to hold panel reg dump\n");
-		rc = -ENOMEM;
-		goto read_reg_fail;
+		return -ENOMEM;
 	}
 
 	if (mdata->debug_inf.debug_enable_clock)
 		mdata->debug_inf.debug_enable_clock(1);
 
 	panel_reg[0] = dbg->off;
+
+	if ((mdata->mdp_rev <= MDSS_MDP_HW_REV_105) ||
+			(mdata->mdp_rev == MDP_CORE_HW_VERSION))
+		panel_data = mdss_res->pdata;
+	else
+		panel_data = ctl->panel_data;
+
+	ctrl_pdata = container_of(panel_data,
+			struct mdss_dsi_ctrl_pdata, panel_data);
+
 	mdss_dsi_panel_cmd_read(ctrl_pdata, panel_reg[0], panel_reg[1],
 				NULL, rx_buf, dbg->cnt);
 
@@ -245,6 +253,8 @@ static ssize_t panel_debug_base_reg_read(struct file *file,
 	if (len < 0)
 		goto read_reg_fail;
 
+	pr_emerg("%s len=%d reg_buf_len=%d rx_len=%d\n",__func__,len,reg_buf_len,ctrl_pdata->rx_len);
+
 	for (i = 0; (len < reg_buf_len) && (i < ctrl_pdata->rx_len); i++)
 		len += scnprintf(panel_reg_buf + len, reg_buf_len - len,
 				"0x%02x ", rx_buf[i]);
@@ -270,7 +280,8 @@ static ssize_t panel_debug_base_reg_read(struct file *file,
 read_reg_fail:
 	kfree(rx_buf);
 	kfree(panel_reg_buf);
-	return rc;
+	return -EFAULT;
+
 }
 
 static const struct file_operations panel_off_fops = {
@@ -1317,7 +1328,7 @@ static inline struct mdss_mdp_misr_map *mdss_misr_get_map(u32 block_id,
 		return NULL;
 	}
 
-	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%pK)\n",
+	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%p)\n",
 			block_id, map->ctrl_reg, map->value_reg, intf_base);
 	return map;
 }
@@ -1360,7 +1371,7 @@ int mdss_misr_set(struct mdss_data_type *mdata,
 	bool use_mdp_up_misr = false;
 
 	if (!mdata || !req || !ctl) {
-		pr_err("Invalid input params: mdata = %pK req = %pK ctl = %pK",
+		pr_err("Invalid input params: mdata = %p req = %p ctl = %p",
 			mdata, req, ctl);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mdss_debug_xlog.c b/drivers/video/msm/mdss/mdss_debug_xlog.c
index 795ff5574c8..c9a4073f50a 100644
--- a/drivers/video/msm/mdss/mdss_debug_xlog.c
+++ b/drivers/video/msm/mdss/mdss_debug_xlog.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -253,7 +253,7 @@ static void mdss_dump_debug_bus(u32 bus_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%pK end_addr:0x%pK\n",
+			pr_info("%s: start_addr:0x%p end_addr:0x%p\n",
 				__func__, dump_addr, dump_addr + list_size);
 		} else {
 			in_mem = false;
@@ -371,7 +371,7 @@ static void mdss_dump_vbif_debug_bus(u32 bus_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%pK end_addr:0x%pK\n",
+			pr_info("%s: start_addr:0x%p end_addr:0x%p\n",
 				__func__, dump_addr, dump_addr + list_size);
 		} else {
 			in_mem = false;
@@ -431,7 +431,7 @@ static void mdss_dump_reg(const char *dump_name, u32 reg_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%pK end_addr:0x%pK reg_addr=0x%pK\n",
+			pr_info("%s: start_addr:0x%p end_addr:0x%p reg_addr=0x%p\n",
 				dump_name, dump_addr, dump_addr + (u32)len * 16,
 				addr);
 		} else {
@@ -450,7 +450,7 @@ static void mdss_dump_reg(const char *dump_name, u32 reg_dump_flag,
 		xc = readl_relaxed(addr+0xc);
 
 		if (in_log)
-			pr_info("%pK : %08x %08x %08x %08x\n", addr, x0, x4, x8,
+			pr_info("%p : %08x %08x %08x %08x\n", addr, x0, x4, x8,
 				xc);
 
 		if (dump_addr && in_mem) {
@@ -486,7 +486,7 @@ static void mdss_dump_reg_by_ranges(struct mdss_debug_base *dbg,
 			len = get_dump_range(&xlog_node->offset,
 				dbg->max_offset);
 			addr = dbg->base + xlog_node->offset.start;
-			pr_debug("%s: range_base=0x%pK start=0x%x end=0x%x\n",
+			pr_debug("%s: range_base=0x%p start=0x%x end=0x%x\n",
 				xlog_node->range_name,
 				addr, xlog_node->offset.start,
 				xlog_node->offset.end);
@@ -496,7 +496,7 @@ static void mdss_dump_reg_by_ranges(struct mdss_debug_base *dbg,
 	} else {
 		/* If there is no list to dump ranges, dump all registers */
 		pr_info("Ranges not found, will dump full registers");
-		pr_info("base:0x%pK len:0x%zu\n", dbg->base, dbg->max_offset);
+		pr_info("base:0x%p len:0x%zu\n", dbg->base, dbg->max_offset);
 		addr = dbg->base;
 		len = dbg->max_offset;
 		mdss_dump_reg((const char *)dbg->name, reg_dump_flag, addr,
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
index 5ad5d7e3688..df5279d9d21 100644
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -256,21 +256,14 @@ static int mdss_dsi_panel_power_off(struct mdss_panel_data *pdata)
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	ret = mdss_dsi_panel_reset(pdata, 0);
-	if (ret) {
-		pr_warn("%s: Panel reset failed. rc=%d\n", __func__, ret);
-		ret = 0;
-	}
-
-	if (mdss_dsi_pinctrl_set_state(ctrl_pdata, false))
-		pr_debug("reset disable: pinctrl not enabled\n");
-
+#ifndef CONFIG_KEEP_POWER_ON_WHEN_PANEL_OFF
 	ret = msm_dss_enable_vreg(
 		ctrl_pdata->panel_power_data.vreg_config,
 		ctrl_pdata->panel_power_data.num_vreg, 0);
 	if (ret)
 		pr_err("%s: failed to disable vregs for %s\n",
 			__func__, __mdss_dsi_pm_name(DSI_PANEL_PM));
+#endif
 
 end:
 	return ret;
@@ -298,6 +291,9 @@ static int mdss_dsi_panel_power_on(struct mdss_panel_data *pdata)
 		return ret;
 	}
 
+	/* delay 20ms for correct power on sequence */
+	msleep(20);
+
 	/*
 	 * If continuous splash screen feature is enabled, then we need to
 	 * request all the GPIOs that have already been configured in the
@@ -308,81 +304,40 @@ static int mdss_dsi_panel_power_on(struct mdss_panel_data *pdata)
 		!pdata->panel_info.mipi.lp11_init) {
 		if (mdss_dsi_pinctrl_set_state(ctrl_pdata, true))
 			pr_debug("reset enable: pinctrl not enabled\n");
-
-		ret = mdss_dsi_panel_reset(pdata, 1);
-		if (ret)
-			pr_err("%s: Panel reset failed. rc=%d\n",
-					__func__, ret);
 	}
 
 	return ret;
 }
 
-/* Panel power control when entering/exiting lp mode */
 static int mdss_dsi_panel_power_lp(struct mdss_panel_data *pdata, int enable)
 {
-	return 0;
-}
-
-static int mdss_dsi_panel_power_ulp(struct mdss_panel_data *pdata,
-					int enable)
-{
-	int ret = 0, i;
+	int ret;
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	u32 mode = enable ? DSS_REG_MODE_ULP : DSS_REG_MODE_ENABLE;
-	struct dsi_shared_data *sdata;
 
-	pr_debug("%s: +\n", __func__);
 	if (pdata == NULL) {
 		pr_err("%s: Invalid input data\n", __func__);
 		return -EINVAL;
 	}
 
+	/* Handle panel idle on after dsi off */
+	if (enable)
+		return 0;
+
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
-	sdata = ctrl_pdata->shared_data;
-
-	for (i = 0; i < DSI_MAX_PM; i++) {
-		/*
-		 * Core power module need to be controlled along with
-		 * DSI core clocks.
-		 */
-		if (DSI_CORE_PM == i)
-			continue;
 
-		if (DSI_PANEL_PM == i)
-			ret = msm_dss_config_vreg_opt_mode(
-				ctrl_pdata->panel_power_data.vreg_config,
-				ctrl_pdata->panel_power_data.num_vreg, mode);
-		else
-			ret = msm_dss_config_vreg_opt_mode(
-				sdata->power_data[i].vreg_config,
-				sdata->power_data[i].num_vreg, mode);
-
-		if (ret) {
-			pr_err("%s: failed to config ulp opt mode for %s.rc=%d\n",
-				__func__, __mdss_dsi_pm_name(i), ret);
-			goto error;
-		}
-	}
-error:
-	if (ret) {
-		mode = enable ? DSS_REG_MODE_ENABLE : DSS_REG_MODE_ULP;
-		for (; i >= 0; i--)
-			msm_dss_config_vreg_opt_mode(
-				ctrl_pdata->power_data[i].vreg_config,
-				ctrl_pdata->power_data[i].num_vreg, mode);
-	}
-	pr_debug("%s: -\n", __func__);
+	/* Panel power control when entering/exiting lp mode */
+	printk("[MDSS] mdss_dsi_panel_power_lp: enable=%d\n", enable);
+	if (ctrl_pdata->low_power_config)
+			ret = ctrl_pdata->low_power_config(pdata, enable);
 	return ret;
 }
 
-int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
+static int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
 	int power_state)
 {
-	int ret = 0;
+	int ret;
 	struct mdss_panel_info *pinfo;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 
 	if (pdata == NULL) {
 		pr_err("%s: Invalid input data\n", __func__);
@@ -390,8 +345,7 @@ int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
 	}
 
 	pinfo = &pdata->panel_info;
-	pr_debug("%pS-->%s: cur_power_state=%d req_power_state=%d\n",
-		__builtin_return_address(0), __func__,
+	pr_debug("%s: cur_power_state=%d req_power_state=%d\n", __func__,
 		pinfo->panel_power_state, power_state);
 
 	if (pinfo->panel_power_state == power_state) {
@@ -399,9 +353,6 @@ int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
 		return 0;
 	}
 
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-
 	/*
 	 * If a dynamic mode switch is pending, the regulators should not
 	 * be turned off or on.
@@ -414,31 +365,15 @@ int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
 		ret = mdss_dsi_panel_power_off(pdata);
 		break;
 	case MDSS_PANEL_POWER_ON:
-		if (mdss_dsi_is_panel_on_ulp(pdata)) {
-			ret = mdss_dsi_panel_power_ulp(pdata, false);
-			goto end;
-		} else if (mdss_dsi_is_panel_on_lp(pdata)) {
+		if (mdss_dsi_is_panel_on_lp(pdata)) {
 			ret = mdss_dsi_panel_power_lp(pdata, false);
-			goto end;
 		} else {
 			ret = mdss_dsi_panel_power_on(pdata);
 		}
 		break;
 	case MDSS_PANEL_POWER_LP1:
-		if (mdss_dsi_is_panel_on_ulp(pdata))
-			ret = mdss_dsi_panel_power_ulp(pdata, false);
-		else
-			ret = mdss_dsi_panel_power_lp(pdata, true);
-		/*
-		 * temp workaround until framework issues pertaining to LP2
-		 * power state transitions are fixed. For now, we internally
-		 * transition to LP2 state whenever core power is turned off
-		 * in LP1 state
-		 */
-		break;
 	case MDSS_PANEL_POWER_LP2:
-		if (!ctrl_pdata->core_power)
-			ret = mdss_dsi_panel_power_ulp(pdata, true);
+		ret = mdss_dsi_panel_power_lp(pdata, true);
 		break;
 	default:
 		pr_err("%s: unknown panel power state requested (%d)\n",
@@ -449,7 +384,6 @@ int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata,
 	if (!ret)
 		pinfo->panel_power_state = power_state;
 
-end:
 	return ret;
 }
 
@@ -559,7 +493,7 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 				__func__, rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_ENABLE] = tmp;
+		mp->vreg_config[i].enable_load = tmp;
 
 		/* disable-load */
 		rc = of_property_read_u32(supply_node,
@@ -569,18 +503,7 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 				__func__, rc);
 			goto error;
 		}
-		mp->vreg_config[i].load[DSS_REG_MODE_DISABLE] = tmp;
-
-		/* ulp-load */
-		rc = of_property_read_u32(supply_node,
-			"qcom,supply-ulp-load", &tmp);
-		if (rc) {
-			pr_warn("%s: error reading ulp load. rc=%d\n",
-				__func__, rc);
-			rc = 0;
-		}
-		mp->vreg_config[i].load[DSS_REG_MODE_ULP] = (!rc ? tmp :
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE]);
+		mp->vreg_config[i].disable_load = tmp;
 
 		/* pre-sleep */
 		rc = of_property_read_u32(supply_node,
@@ -624,14 +547,13 @@ static int mdss_dsi_get_dt_vreg_data(struct device *dev,
 			mp->vreg_config[i].post_off_sleep = tmp;
 		}
 
-		pr_debug("%s: %s min=%d, max=%d, enable=%d, disable=%d, ulp_load=%d preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
+		pr_debug("%s: %s min=%d, max=%d, enable=%d, disable=%d, preonsleep=%d, postonsleep=%d, preoffsleep=%d, postoffsleep=%d\n",
 			__func__,
 			mp->vreg_config[i].vreg_name,
 			mp->vreg_config[i].min_voltage,
 			mp->vreg_config[i].max_voltage,
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE],
-			mp->vreg_config[i].load[DSS_REG_MODE_DISABLE],
-			mp->vreg_config[i].load[DSS_REG_MODE_ULP],
+			mp->vreg_config[i].enable_load,
+			mp->vreg_config[i].disable_load,
 			mp->vreg_config[i].pre_on_sleep,
 			mp->vreg_config[i].post_on_sleep,
 			mp->vreg_config[i].pre_off_sleep,
@@ -1046,7 +968,6 @@ static void mdss_dsi_debugfs_cleanup(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
 		struct mdss_dsi_debugfs_info *dfs = ctrl->debugfs_info;
 		if (dfs && dfs->root)
 			debugfs_remove_recursive(dfs->root);
-		kfree(dfs);
 		pdata = pdata->next;
 	} while (pdata);
 	pr_debug("%s: Cleaned up mdss_dsi_debugfs_info\n", __func__);
@@ -1185,7 +1106,7 @@ static int mdss_dsi_off(struct mdss_panel_data *pdata, int power_state)
 	mutex_lock(&ctrl_pdata->mutex);
 	panel_info = &ctrl_pdata->panel_data.panel_info;
 
-	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 
 	if (power_state == panel_info->panel_power_state) {
@@ -1369,7 +1290,7 @@ int mdss_dsi_on(struct mdss_panel_data *pdata)
 		mdss_dsi_validate_debugfs_info(ctrl_pdata);
 
 	cur_power_state = pdata->panel_info.panel_power_state;
-	pr_debug("%s+: ctrl=%pK ndx=%d cur_power_state=%d\n", __func__,
+	pr_debug("%s+: ctrl=%p ndx=%d cur_power_state=%d\n", __func__,
 		ctrl_pdata, ctrl_pdata->ndx, cur_power_state);
 
 	pinfo = &pdata->panel_info;
@@ -1547,7 +1468,7 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 				panel_data);
 	mipi  = &pdata->panel_info.mipi;
 
-	pr_debug("%s+: ctrl=%pK ndx=%d cur_power_state=%d ctrl_state=%x\n",
+	pr_debug("%s+: ctrl=%p ndx=%d cur_power_state=%d ctrl_state=%x\n",
 			__func__, ctrl_pdata, ctrl_pdata->ndx,
 		pdata->panel_info.panel_power_state, ctrl_pdata->ctrl_state);
 
@@ -1562,7 +1483,7 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 		mdss_dsi_clk_ctrl(sctrl, sctrl->dsi_clk_handle,
 				  MDSS_DSI_ALL_CLKS, MDSS_DSI_CLK_ON);
 
-	if (pdata->panel_info.blank_state == MDSS_PANEL_BLANK_LOW_POWER) {
+	if (mdss_dsi_is_panel_on_lp(pdata)) {
 		pr_debug("%s: dsi_unblank with panel always on\n", __func__);
 		if (ctrl_pdata->low_power_config)
 			ret = ctrl_pdata->low_power_config(pdata, false);
@@ -1587,6 +1508,8 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 	if ((pdata->panel_info.type == MIPI_CMD_PANEL) &&
 		mipi->vsync_enable && mipi->hw_vsync_mode) {
 		mdss_dsi_set_tear_on(ctrl_pdata);
+		if (mdss_dsi_is_te_based_esd(ctrl_pdata))
+			enable_irq(gpio_to_irq(ctrl_pdata->disp_te_gpio));
 	}
 
 error:
@@ -1618,7 +1541,7 @@ static int mdss_dsi_blank(struct mdss_panel_data *pdata, int power_state)
 				panel_data);
 	mipi = &pdata->panel_info.mipi;
 
-	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, ctrl_pdata->dsi_clk_handle,
@@ -1652,6 +1575,11 @@ static int mdss_dsi_blank(struct mdss_panel_data *pdata, int power_state)
 
 	if ((pdata->panel_info.type == MIPI_CMD_PANEL) &&
 		mipi->vsync_enable && mipi->hw_vsync_mode) {
+		if (mdss_dsi_is_te_based_esd(ctrl_pdata)) {
+				disable_irq(gpio_to_irq(
+					ctrl_pdata->disp_te_gpio));
+				atomic_dec(&ctrl_pdata->te_irq_ready);
+		}
 		mdss_dsi_set_tear_off(ctrl_pdata);
 	}
 
@@ -1687,7 +1615,7 @@ static int mdss_dsi_post_panel_on(struct mdss_panel_data *pdata)
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s+: ctrl=%pK ndx=%d\n", __func__,
+	pr_debug("%s+: ctrl=%p ndx=%d\n", __func__,
 				ctrl_pdata, ctrl_pdata->ndx);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, ctrl_pdata->dsi_clk_handle,
@@ -1721,7 +1649,7 @@ int mdss_dsi_cont_splash_on(struct mdss_panel_data *pdata)
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s+: ctrl=%pK ndx=%d\n", __func__,
+	pr_debug("%s+: ctrl=%p ndx=%d\n", __func__,
 				ctrl_pdata, ctrl_pdata->ndx);
 
 	WARN((ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT),
@@ -2998,8 +2926,8 @@ static int mdss_dsi_get_bridge_chip_params(struct mdss_panel_info *pinfo,
 	u32 temp_val = 0;
 
 	if (!ctrl_pdata || !pdev || !pinfo) {
-		pr_err("%s: Invalid Params ctrl_pdata=%pK, pdev=%pK\n",
-			 __func__, ctrl_pdata, pdev);
+		pr_err("%s: Invalid Params ctrl_pdata=%p, pdev=%p\n", __func__,
+			ctrl_pdata, pdev);
 		rc = -EINVAL;
 		goto end;
 	}
@@ -3143,7 +3071,6 @@ static int mdss_dsi_ctrl_probe(struct platform_device *pdev)
 	}
 
 	if (mdss_dsi_is_te_based_esd(ctrl_pdata)) {
-		init_completion(&ctrl_pdata->te_irq_comp);
 		rc = devm_request_irq(&pdev->dev,
 			gpio_to_irq(ctrl_pdata->disp_te_gpio),
 			hw_vsync_handler, IRQF_TRIGGER_FALLING,
@@ -3321,7 +3248,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 		mdss_dsi_res->shared_data = devm_kzalloc(&pdev->dev,
 				sizeof(struct dsi_shared_data),
 				GFP_KERNEL);
-		pr_debug("%s Allocated shared_data=%pK\n", __func__,
+		pr_debug("%s Allocated shared_data=%p\n", __func__,
 				mdss_dsi_res->shared_data);
 		if (!mdss_dsi_res->shared_data) {
 			pr_err("%s Unable to alloc mem for shared_data\n",
@@ -3386,7 +3313,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 				rc = -ENOMEM;
 				goto mem_fail;
 			}
-			pr_debug("%s Allocated ctrl_pdata[%d]=%pK\n",
+			pr_debug("%s Allocated ctrl_pdata[%d]=%p\n",
 				__func__, i, mdss_dsi_res->ctrl_pdata[i]);
 			mdss_dsi_res->ctrl_pdata[i]->shared_data =
 				mdss_dsi_res->shared_data;
@@ -3396,7 +3323,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 	}
 
 	mdss_dsi_res->pdev = pdev;
-	pr_debug("%s: Setting up mdss_dsi_res=%pK\n", __func__, mdss_dsi_res);
+	pr_debug("%s: Setting up mdss_dsi_res=%p\n", __func__, mdss_dsi_res);
 
 	return 0;
 
@@ -3668,6 +3595,28 @@ static int mdss_dsi_ctrl_remove(struct platform_device *pdev)
 
 struct device dsi_dev;
 
+#ifdef CONFIG_KEEP_POWER_ON_WHEN_PANEL_OFF
+static void mdss_dsi_ctrl_shutdown(struct platform_device *pdev)
+{
+	struct mdss_dsi_ctrl_pdata *ctrl_pdata = platform_get_drvdata(pdev);
+	int i = 0, ret = 0;
+
+	pr_debug("%s: zw3 panel power off\n", __func__);
+
+	if (!ctrl_pdata) {
+		pr_err("%s: no driver data\n", __func__);
+	}
+
+	gpio_set_value((ctrl_pdata->rst_gpio), 0);
+
+	for (i = DSI_MAX_PM - 1; i >= 0; i--) {
+		ret = msm_dss_enable_vreg(
+			ctrl_pdata->power_data[i].vreg_config,
+			ctrl_pdata->power_data[i].num_vreg, 0);
+	}
+}
+#endif
+
 int mdss_dsi_retrieve_ctrl_resources(struct platform_device *pdev, int mode,
 			struct mdss_dsi_ctrl_pdata *ctrl)
 {
@@ -3723,11 +3672,11 @@ int mdss_dsi_retrieve_ctrl_resources(struct platform_device *pdev, int mode,
 		pr_debug("%s:%d unable to remap dsi phy regulator resources\n",
 			       __func__, __LINE__);
 	else
-		pr_info("%s: phy_regulator_base=%pK phy_regulator_size=%x\n",
+		pr_info("%s: phy_regulator_base=%p phy_regulator_size=%x\n",
 			__func__, ctrl->phy_regulator_io.base,
 			ctrl->phy_regulator_io.len);
 
-	pr_info("%s: ctrl_base=%pK ctrl_size=%x phy_base=%pK phy_size=%x\n",
+	pr_info("%s: ctrl_base=%p ctrl_size=%x phy_base=%p phy_size=%x\n",
 		__func__, ctrl->ctrl_base, ctrl->reg_size, ctrl->phy_io.base,
 		ctrl->phy_io.len);
 
@@ -3871,7 +3820,7 @@ static int mdss_dsi_parse_ctrl_params(struct platform_device *ctrl_pdev,
 	data = of_get_property(ctrl_pdev->dev.of_node,
 		"qcom,display-id", &len);
 	if (!data || len <= 0)
-		pr_err("%s:%d Unable to read qcom,display-id, data=%pK,len=%d\n",
+		pr_err("%s:%d Unable to read qcom,display-id, data=%p,len=%d\n",
 			__func__, __LINE__, data, len);
 	else
 		snprintf(ctrl_pdata->panel_data.panel_info.display_id,
@@ -3899,13 +3848,8 @@ static int mdss_dsi_parse_gpio_params(struct platform_device *ctrl_pdev,
 		if (!gpio_is_valid(ctrl_pdata->disp_en_gpio))
 			pr_debug("%s:%d, Disp_en gpio not specified\n",
 					__func__, __LINE__);
-		else {
-			int ret = gpio_direction_output(ctrl_pdata->disp_en_gpio, 1);
-			if (ret){
-				pr_err("%s: Set direction for gpio_panel_en failed, ret=%d\n",__func__, ret);
-			}
-		}
 	}
+
 	ctrl_pdata->disp_te_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
 		"qcom,platform-te-gpio", 0);
 
@@ -4145,7 +4089,9 @@ static struct platform_driver mdss_dsi_driver = {
 static struct platform_driver mdss_dsi_ctrl_driver = {
 	.probe = mdss_dsi_ctrl_probe,
 	.remove = mdss_dsi_ctrl_remove,
-	.shutdown = NULL,
+#ifdef CONFIG_KEEP_POWER_ON_WHEN_PANEL_OFF
+	.shutdown = mdss_dsi_ctrl_shutdown,
+#endif
 	.driver = {
 		.name = "mdss_dsi_ctrl",
 		.of_match_table = mdss_dsi_ctrl_dt_match,
diff --git a/drivers/video/msm/mdss/mdss_dsi.h b/drivers/video/msm/mdss/mdss_dsi.h
index 25a1673cb65..e6428ff98d8 100644
--- a/drivers/video/msm/mdss/mdss_dsi.h
+++ b/drivers/video/msm/mdss/mdss_dsi.h
@@ -19,8 +19,6 @@
 #include <linux/irqreturn.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/gpio.h>
-#include <linux/wakelock.h>
-
 
 #include "mdss_panel.h"
 #include "mdss_dsi_cmd.h"
@@ -396,8 +394,6 @@ struct mdss_dsi_ctrl_pdata {
 	int (*post_panel_on)(struct mdss_panel_data *pdata);
 	int (*off) (struct mdss_panel_data *pdata);
 	int (*low_power_config) (struct mdss_panel_data *pdata, int enable);
-	int (*boost_mode_config) (struct mdss_panel_data *pdata, int enable);
-	int (*set_acl) (struct mdss_panel_data *pdata, int enable);
 	int (*set_col_page_addr)(struct mdss_panel_data *pdata, bool force);
 	int (*check_status) (struct mdss_dsi_ctrl_pdata *pdata);
 	int (*check_read_status) (struct mdss_dsi_ctrl_pdata *pdata);
@@ -465,18 +461,8 @@ struct mdss_dsi_ctrl_pdata {
 	struct dsi_panel_cmds post_dms_on_cmds;
 	struct dsi_panel_cmds post_panel_on_cmds;
 	struct dsi_panel_cmds off_cmds;
+	struct dsi_panel_cmds sleep_cmds;
 	struct dsi_panel_cmds status_cmds;
-	int idle;
-	int ulps_mode;
-	int boost;
-	struct dsi_panel_cmds idle_on_cmds;
-	struct dsi_panel_cmds idle_off_cmds;
-	struct dsi_panel_cmds boost_on_cmds;
-	struct dsi_panel_cmds boost_off_cmds;
-	struct dsi_panel_cmds brightness_cmds;
-	struct work_struct idle_on_work;
-	struct wake_lock idle_on_wakelock;
-
 	u32 *status_valid_params;
 	u32 *status_cmds_rlen;
 	u32 *status_value;
@@ -496,7 +482,6 @@ struct mdss_dsi_ctrl_pdata {
 	struct completion video_comp;
 	struct completion dynamic_comp;
 	struct completion bta_comp;
-	struct completion te_irq_comp;
 	spinlock_t irq_lock;
 	spinlock_t mdp_lock;
 	int mdp_busy;
@@ -556,7 +541,13 @@ struct mdss_dsi_ctrl_pdata {
 
 	bool timing_db_mode;
 	bool update_phy_timing; /* flag to recalculate PHY timings */
-	bool acl_enable;
+
+	/* ASUS extend properties for panel low power mode */
+	struct mutex blcmd_mutex;
+	struct mutex ambientcmd_mutex;
+
+	struct dsi_panel_cmds idle_on_cmds;
+	struct dsi_panel_cmds idle_off_cmds;
 };
 
 struct dsi_status_data {
@@ -671,7 +662,6 @@ void mdss_dsi_dsc_config(struct mdss_dsi_ctrl_pdata *ctrl,
 	struct dsc_desc *dsc);
 void mdss_dsi_dfps_config_8996(struct mdss_dsi_ctrl_pdata *ctrl);
 void mdss_dsi_set_burst_mode(struct mdss_dsi_ctrl_pdata *ctrl);
-int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata, int power_state);
 
 static inline const char *__mdss_dsi_pm_name(enum dsi_pm_type module)
 {
@@ -876,11 +866,6 @@ static inline bool mdss_dsi_is_panel_on_lp(struct mdss_panel_data *pdata)
 	return mdss_panel_is_power_on_lp(pdata->panel_info.panel_power_state);
 }
 
-static inline bool mdss_dsi_is_panel_on_ulp(struct mdss_panel_data *pdata)
-{
-	return mdss_panel_is_power_on_ulp(pdata->panel_info.panel_power_state);
-}
-
 static inline bool mdss_dsi_ulps_feature_enabled(
 	struct mdss_panel_data *pdata)
 {
diff --git a/drivers/video/msm/mdss/mdss_dsi_clk.c b/drivers/video/msm/mdss/mdss_dsi_clk.c
index e92f6df03a2..bac839132c8 100644
--- a/drivers/video/msm/mdss/mdss_dsi_clk.c
+++ b/drivers/video/msm/mdss/mdss_dsi_clk.c
@@ -732,7 +732,7 @@ int mdss_dsi_clk_req_state(void *client, enum mdss_dsi_clk_type clk,
 
 	if (!client || !clk || clk > (MDSS_DSI_CORE_CLK | MDSS_DSI_LINK_CLK) ||
 	    state > MDSS_DSI_CLK_EARLY_GATE) {
-		pr_err("Invalid params, client = %pK, clk = 0x%x, state = %d\n",
+		pr_err("Invalid params, client = %p, clk = 0x%x, state = %d\n",
 		       client, clk, state);
 		return -EINVAL;
 	}
@@ -830,7 +830,7 @@ int mdss_dsi_clk_set_link_rate(void *client, enum mdss_dsi_link_clk_type clk,
 	struct mdss_dsi_clk_mngr *mngr;
 
 	if (!client || (clk > MDSS_DSI_LINK_CLK_MAX)) {
-		pr_err("Invalid params, client = %pK, clk = 0x%x", client, clk);
+		pr_err("Invalid params, client = %p, clk = 0x%x", client, clk);
 		return -EINVAL;
 	}
 
@@ -929,7 +929,7 @@ int mdss_dsi_clk_force_toggle(void *client, u32 clk)
 	struct mdss_dsi_clk_mngr *mngr;
 
 	if (!client || !clk || clk >= MDSS_DSI_CLKS_MAX) {
-		pr_err("Invalid params, client = %pK, clk = 0x%x\n",
+		pr_err("Invalid params, client = %p, clk = 0x%x\n",
 		       client, clk);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mdss_dsi_cmd.c b/drivers/video/msm/mdss/mdss_dsi_cmd.c
index ca668520905..d07b504ff30 100644
--- a/drivers/video/msm/mdss/mdss_dsi_cmd.c
+++ b/drivers/video/msm/mdss/mdss_dsi_cmd.c
@@ -757,8 +757,6 @@ int mdss_dsi_cmdlist_put(struct mdss_dsi_ctrl_pdata *ctrl,
 	struct dcs_cmd_list *clist;
 	int ret = 0;
 
-	if(ctrl->ulps_mode)
-		return ret;
 	mutex_lock(&ctrl->cmd_mutex);
 	mutex_lock(&ctrl->cmdlist_mutex);
 	clist = &ctrl->cmdlist;
diff --git a/drivers/video/msm/mdss/mdss_dsi_host.c b/drivers/video/msm/mdss/mdss_dsi_host.c
old mode 100755
new mode 100644
index 7c9db5807c1..7d1a0f0ad89
--- a/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -102,7 +102,7 @@ void mdss_dsi_ctrl_init(struct device *ctrl_dev,
 	if (ctrl->mdss_util->register_irq(ctrl->dsi_hw))
 		pr_err("%s: mdss_register_irq failed.\n", __func__);
 
-	pr_debug("%s: ndx=%d base=%pK\n", __func__, ctrl->ndx, ctrl->ctrl_base);
+	pr_debug("%s: ndx=%d base=%p\n", __func__, ctrl->ndx, ctrl->ctrl_base);
 
 	init_completion(&ctrl->dma_comp);
 	init_completion(&ctrl->mdp_comp);
@@ -113,6 +113,8 @@ void mdss_dsi_ctrl_init(struct device *ctrl_dev,
 	spin_lock_init(&ctrl->mdp_lock);
 	mutex_init(&ctrl->mutex);
 	mutex_init(&ctrl->cmd_mutex);
+	mutex_init(&ctrl->blcmd_mutex);
+	mutex_init(&ctrl->ambientcmd_mutex);
 	mutex_init(&ctrl->clk_lane_mutex);
 	mutex_init(&ctrl->cmdlist_mutex);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->tx_buf, SZ_4K);
@@ -1633,13 +1635,6 @@ static int mdss_dsi_cmds2buf_tx(struct mdss_dsi_ctrl_pdata *ctrl,
 			}
 			pr_debug("%s: cmd_dma_tx for cmd = 0x%x, len = %d\n",
 					__func__,  cm->payload[0], len);
-			/*check if 0x22 cmd is set to change panel to all pixel off*/
-			if (0x22 == cm->payload[0])
-			{
-				pr_err("%s: cmd_dma_tx for cmd = 0x%x, len = %d\n",
-					__func__,  cm->payload[0], len);
-				WARN_ON(1);
-			}
 
 			if (!wait || dchdr->wait > VSYNC_PERIOD)
 				usleep_range(dchdr->wait * 1000, dchdr->wait * 1000);
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index a1a5bd38f62..8d9612b4269 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -27,6 +27,17 @@
 #ifdef TARGET_HW_MDSS_HDMI
 #include "mdss_dba_utils.h"
 #endif
+
+#include <linux/debugfs.h>
+#ifdef CONFIG_ASUS_BACKLIGHT_DEBUG
+#include <linux/uaccess.h>
+#endif
+
+
+#ifdef CONFIG_ASUS_BACKLIGHT_DEBUG
+static int brightness_lock = 0;
+#endif
+
 #define DT_CMD_HDR 6
 #define MIN_REFRESH_RATE 48
 #define DEFAULT_MDP_TRANSFER_TIME 14000
@@ -35,21 +46,6 @@
 
 DEFINE_LED_TRIGGER(bl_led_trigger);
 
-#define ACL_CMD_CNT  4
-static unsigned char acl1[] = {0xfe, 0x06};	/* DTYPE_DCS_WRITE */
-static unsigned char acl2[] = {0xac, 0x02};	/* DTYPE_DCS_WRITE */
-static unsigned char acl3[] = {0xfe, 0x00};	/* DTYPE_DCS_WRITE */
-static unsigned char acl4[] = {0x55, 0x01};	/* DTYPE_DCS_WRITE */
-
-
-/* set ACL enable */
-static struct dsi_cmd_desc set_acl_addr_cmd[] = {
-	{{DTYPE_DCS_WRITE1, 0, 0, 0, 1, sizeof(acl1)}, acl1},
-	{{DTYPE_DCS_WRITE1, 0, 0, 0, 1, sizeof(acl2)}, acl2},
-	{{DTYPE_DCS_WRITE1, 0, 0, 0, 1, sizeof(acl3)}, acl3},
-	{{DTYPE_DCS_WRITE1, 1, 0, 0, 1, sizeof(acl4)}, acl4},
-};
-
 void mdss_dsi_panel_pwm_cfg(struct mdss_dsi_ctrl_pdata *ctrl)
 {
 	if (ctrl->pwm_pmi)
@@ -205,79 +201,23 @@ static void mdss_dsi_panel_cmds_send(struct mdss_dsi_ctrl_pdata *ctrl,
 	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
 }
 
-
-static int mdss_dsi_panel_acl_dcs(struct mdss_panel_data *pdata, int enable)
-{
-	struct dcs_cmd_req cmdreq = { 0 };
-	struct mdss_panel_info *pinfo = NULL ;
-	struct mdss_dsi_ctrl_pdata *ctrl = NULL;
-
-	if ( NULL == pdata )
-	{
-		pr_err("%s: Invalid input data\n", __func__);
-		return -1;
-	}
-	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-						panel_data);
-	if ( NULL == ctrl )
-	{
-		pr_err("%s: ctrl data error\n", __func__);
-		return -1;
-	}
-
-	pinfo = &pdata->panel_info;
-	if ( NULL == pinfo )
-	{
-		pr_err("%s: panel info error", __func__);
-		return -1;
-	}
-
-
-	if( MDSS_PANEL_POWER_OFF == pinfo->panel_power_state )
-	{
-		pr_err("%s: panel_power_state is MDSS_PANEL_POWER_OFF", __func__);
-		return -1;
-	}
-
-	if (pinfo->dcs_cmd_by_left) {
-		if (ctrl->ndx != DSI_CTRL_LEFT)
-			return -1;
-	}
-	pr_err("%s: acl=%d\n", __func__, enable);
-
-	acl4[1] = enable;
-
-	cmdreq.cmds = set_acl_addr_cmd;
-	cmdreq.cmds_cnt = ACL_CMD_CNT;
-	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
-	cmdreq.rlen = 0;
-	cmdreq.cb = NULL;
-
-	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
-
-	return 0;
-}
-
 static char led_pwm1[2] = {0x51, 0x0};	/* DTYPE_DCS_WRITE1 */
 static struct dsi_cmd_desc backlight_cmd = {
 	{DTYPE_DCS_WRITE1, 1, 0, 0, 1, sizeof(led_pwm1)},
 	led_pwm1
 };
-static int mdss_dsi_panel_boost_config(struct mdss_panel_data *pdata,
-	int enable);
 
 static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 {
 	struct dcs_cmd_req cmdreq;
 	struct mdss_panel_info *pinfo;
-	struct mdss_panel_data *pdata;
 
 	pinfo = &(ctrl->panel_data.panel_info);
 	if (pinfo->dcs_cmd_by_left) {
 		if (ctrl->ndx != DSI_CTRL_LEFT)
 			return;
 	}
-	pdata = &ctrl->panel_data;
+
 	pr_debug("%s: level=%d\n", __func__, level);
 
 	led_pwm1[1] = (unsigned char)level;
@@ -290,67 +230,6 @@ static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 	cmdreq.cb = NULL;
 
 	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
-
-	if(255 == level){
-		pr_err("%s: open boost mode\n", __func__);
-		mdss_dsi_panel_boost_config(pdata, 1);
-	 }
-	else if (255 == pinfo->bl_pre){
-		pr_err("%s: close boost mode\n", __func__);
-		mdss_dsi_panel_boost_config(pdata, 0);
-	}
-
-	pinfo->bl_pre = level;
-
-}
-
-static void mdss_dsi_panel_set_idle_mode(struct mdss_panel_data *pdata,
-							int enable)
-{
-	struct mdss_dsi_ctrl_pdata *ctrl = NULL;
-
-	if (pdata == NULL) {
-		pr_err("%s: Invalid input data\n", __func__);
-		return;
-	}
-
-	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-						panel_data);
-
-	pr_debug("%s: Idle (%d->%d)\n", __func__, ctrl->idle, enable);
-
-	if (ctrl->idle == enable)
-		return;
-
-	ctrl->idle = enable;
-
-	if (enable) {
-		if (ctrl->idle_on_cmds.cmd_cnt){
-			mdss_dsi_panel_cmds_send(ctrl, &ctrl->idle_on_cmds,
-					CMD_REQ_COMMIT);
-			pr_info("Idle on \n");
-		}
-	} else {
-		if (ctrl->idle_off_cmds.cmd_cnt) {
-			mdss_dsi_panel_cmds_send(ctrl, &ctrl->idle_off_cmds,
-					CMD_REQ_COMMIT);
-			pr_info("Idle off \n");
-		}
-	}
-}
-
-static int mdss_dsi_panel_get_idle_mode(struct mdss_panel_data *pdata)
-{
-	struct mdss_dsi_ctrl_pdata *ctrl = NULL;
-	if (pdata == NULL) {
-		pr_err("%s: Invalid input data\n", __func__);
-		return 0;
-	}
-
-	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-						panel_data);
-
-	return ctrl->idle;
 }
 
 static int mdss_dsi_request_gpios(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
@@ -477,19 +356,12 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 			gpio_set_value((ctrl_pdata->bklt_en_gpio), 0);
 			gpio_free(ctrl_pdata->bklt_en_gpio);
 		}
-		pr_info("power off the panel!\n");
-		if(ctrl_pdata->ulps_mode){
-			pr_info("Nothing to be done for panel GPIOs in ULPM mode!\n");
-		}else{
-			gpio_set_value((ctrl_pdata->rst_gpio), 1);
-			if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
-				gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
-				gpio_free(ctrl_pdata->disp_en_gpio);
-			}
-			mdelay(15);    /*15ms delay for pull reset pin low*/
-			gpio_free(ctrl_pdata->rst_gpio);
+		if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
+			gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
+			gpio_free(ctrl_pdata->disp_en_gpio);
 		}
-
+		gpio_set_value((ctrl_pdata->rst_gpio), 0);
+		gpio_free(ctrl_pdata->rst_gpio);
 		if (gpio_is_valid(ctrl_pdata->mode_gpio))
 			gpio_free(ctrl_pdata->mode_gpio);
 	}
@@ -743,6 +615,13 @@ static void mdss_dsi_panel_bl_ctrl(struct mdss_panel_data *pdata,
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 	struct mdss_dsi_ctrl_pdata *sctrl = NULL;
 
+	pr_debug("%s: level %d\n", __func__,bl_level);
+
+#ifdef CONFIG_ASUS_BACKLIGHT_DEBUG
+    if(brightness_lock)
+        return;
+#endif
+
 	if (pdata == NULL) {
 		pr_err("%s: Invalid input data\n", __func__);
 		return;
@@ -840,11 +719,6 @@ static int mdss_dsi_panel_on(struct mdss_panel_data *pdata)
 		mdss_dba_utils_video_on(pinfo->dba_data, pinfo);
 #endif
 end:
-	pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
-	if( ctrl->acl_enable )
-	{
-		mdss_dsi_panel_acl_dcs(pdata, true );
-	}
 	pr_debug("%s:-\n", __func__);
 	return ret;
 }
@@ -865,7 +739,7 @@ static int mdss_dsi_post_panel_on(struct mdss_panel_data *pdata)
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%pK ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
 
 	pinfo = &pdata->panel_info;
 	if (pinfo->dcs_cmd_by_left && ctrl->ndx != DSI_CTRL_LEFT)
@@ -873,8 +747,7 @@ static int mdss_dsi_post_panel_on(struct mdss_panel_data *pdata)
 
 	cmds = &ctrl->post_panel_on_cmds;
 	if (cmds->cmd_cnt) {
-		if (pinfo->mipi.init_delay)
-			msleep(VSYNC_DELAY);	/* wait for a vsync passed */
+		msleep(VSYNC_DELAY);	/* wait for a vsync passed */
 		mdss_dsi_panel_cmds_send(ctrl, cmds, CMD_REQ_COMMIT);
 	}
 
@@ -905,7 +778,7 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%pK ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
 
 	if (pinfo->dcs_cmd_by_left) {
 		if (ctrl->ndx != DSI_CTRL_LEFT)
@@ -914,6 +787,11 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 
 	if (ctrl->off_cmds.cmd_cnt)
 		mdss_dsi_panel_cmds_send(ctrl, &ctrl->off_cmds, CMD_REQ_COMMIT);
+
+	usleep_range(30*1000,30*1000);
+
+	if (ctrl->sleep_cmds.cmd_cnt)
+		mdss_dsi_panel_cmds_send(ctrl, &ctrl->sleep_cmds, CMD_REQ_COMMIT);
 #ifdef TARGET_HW_MDSS_HDMI
 	if (ctrl->ds_registered && pinfo->is_pluggable) {
 		mdss_dba_utils_video_off(pinfo->dba_data);
@@ -921,56 +799,10 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 	}
 #endif
 end:
-	pinfo->blank_state = MDSS_PANEL_BLANK_BLANK;
-	/*clear idle state*/
-	ctrl->idle = 0;
 	pr_debug("%s:-\n", __func__);
 	return 0;
 }
 
-static void idle_on_work(struct work_struct *work)
-{
-	struct mdss_dsi_ctrl_pdata *ctrl =
-		container_of(work, struct mdss_dsi_ctrl_pdata, idle_on_work);
-	struct mdss_panel_info *pinfo;
-	struct dsi_panel_cmds single_cmd;
-	struct dsi_panel_cmds *idle_cmd;
-	int i = 0;
-	int delay;
-
-	pinfo = &(ctrl->panel_data.panel_info);
-	idle_cmd = &ctrl->idle_on_cmds;
-
-	pr_err("%s ++\n", __func__);
-	wake_lock(&ctrl->idle_on_wakelock);
-
-	if(ctrl->idle == false)
-		goto end;
-
-	if(pinfo->blank_state == MDSS_PANEL_BLANK_BLANK)
-		goto end;
-
-	do {
-		single_cmd.cmds = idle_cmd->cmds+i;
-		single_cmd.cmd_cnt = 1;
-		delay = (idle_cmd->cmds+i)->dchdr.wait;
-		(idle_cmd->cmds+i)->dchdr.wait = 0;
-		mdss_dsi_panel_cmds_send(ctrl, &single_cmd, CMD_REQ_COMMIT);
-
-		if (delay) {
-			msleep(delay);
-			(idle_cmd->cmds+i)->dchdr.wait = delay;
-		}
-
-	} while (++i < idle_cmd->cmd_cnt);
-
-end:
-	wake_unlock(&ctrl->idle_on_wakelock);
-	pr_err("%s --\n", __func__);
-
-	return;
-}
-
 static int mdss_dsi_panel_low_power_config(struct mdss_panel_data *pdata,
 	int enable)
 {
@@ -986,73 +818,33 @@ static int mdss_dsi_panel_low_power_config(struct mdss_panel_data *pdata,
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%pK ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
+	printk("%s: ctrl=%p ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
 		enable);
 
-	/* Any panel specific low power commands/config */
-	if(ctrl->idle == enable){
-		pr_debug("%s: idle: no change(%d)\n",__func__,enable);
-		return 0;
-	}
-
-	ctrl->idle = enable;
-	if (enable)
-	{
-
-		if(ctrl->idle_on_cmds.cmd_cnt){
-			pinfo->blank_state = MDSS_PANEL_BLANK_LOW_POWER;
-			schedule_work(&ctrl->idle_on_work);}
-	}
-	else
-	{
+	mutex_lock(&ctrl->ambientcmd_mutex);
 
-		if(ctrl->idle_on_cmds.cmd_cnt){
-			pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
-			cancel_work_sync(&ctrl->idle_on_work);
-			mdss_dsi_panel_cmds_send(ctrl, &ctrl->idle_off_cmds, CMD_REQ_COMMIT);}
+	/* Any panel specific low power commands/config */
+	if (enable) {
+		if (ctrl->idle_on_cmds.cmd_cnt){
+			printk("MDSS:AMB: set idle ON command!\n");
+			mdss_dsi_panel_cmds_send(ctrl, &ctrl->idle_on_cmds, CMD_REQ_COMMIT);
+		} else {
+			printk("MDSS:AMB: idle ON command is not set!\n");
+		}
+	} else {
+		if (ctrl->idle_off_cmds.cmd_cnt){
+			printk("MDSS:AMB: set idle OFF command!\n");
+			mdss_dsi_panel_cmds_send(ctrl, &ctrl->idle_off_cmds, CMD_REQ_COMMIT);
+		} else {
+			printk("MDSS:AMB: idle OFF command is not set!\n");
+		}
 	}
 
+	mutex_unlock(&ctrl->ambientcmd_mutex);
 	pr_debug("%s:-\n", __func__);
 	return 0;
 }
 
-static int mdss_dsi_panel_boost_config(struct mdss_panel_data *pdata,
-	int enable)
-{
-	struct mdss_dsi_ctrl_pdata *ctrl = NULL;
-	struct mdss_panel_info *pinfo;
-
-	if (pdata == NULL) {
-		pr_err("%s: Invalid input data\n", __func__);
-		return -EINVAL;
-	}
-
-	pinfo = &pdata->panel_info;
-	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-
-	if(ctrl->boost == enable){
-		pr_debug("%s: idle: no change(%d)\n",__func__,enable);
-		return 0;
-	}
-
-	ctrl->boost = enable;
-	if (enable)
-	{
-
-		if(ctrl->boost_on_cmds.cmd_cnt){
-			mdss_dsi_panel_cmds_send(ctrl, &ctrl->boost_on_cmds, CMD_REQ_COMMIT);}
-	}
-	else
-	{
-
-		if(ctrl->boost_off_cmds.cmd_cnt){
-			mdss_dsi_panel_cmds_send(ctrl, &ctrl->boost_off_cmds, CMD_REQ_COMMIT);}
-	}
-
-	return 0;
-}
-
 static void mdss_dsi_parse_trigger(struct device_node *np, char *trigger,
 		char *trigger_key)
 {
@@ -2315,7 +2107,7 @@ static int mdss_dsi_panel_timing_from_dt(struct device_node *np,
 
 	if (np->name) {
 		pt->timing.name = kstrdup(np->name, GFP_KERNEL);
-		pr_info("%s: found new timing \"%s\" (%pK)\n", __func__,
+		pr_info("%s: found new timing \"%s\" (%p)\n", __func__,
 				np->name, &pt->timing);
 	}
 
@@ -2624,20 +2416,12 @@ static int mdss_panel_parse_dt(struct device_node *np,
 
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->off_cmds,
 		"qcom,mdss-dsi-off-command", "qcom,mdss-dsi-off-command-state");
-
+	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->sleep_cmds,
+			"qcom,mdss-dsi-sleep-command", "qcom,mdss-dsi-sleep-command-state");
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->idle_on_cmds,
-		"qcom,mdss-dsi-idle-on-command", "qcom,mdss-dsi-idle-on-command-state");
-
+		"qcom,mdss-dsi-idle-on-command", "qcom,mdss-dsi-on-command-state");
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->idle_off_cmds,
-		"qcom,mdss-dsi-idle-off-command", "qcom,mdss-dsi-idle-off-command-state");
-
-	rc = of_property_read_u32(np, "qcom,mdss-dsi-idle-fps", &tmp);
-	pinfo->mipi.frame_rate_idle = (!rc ? tmp : 60);
-	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->boost_on_cmds,
-		"qcom,mdss-dsi-boost-on-command", "qcom,mdss-dsi-boost-on-command-state");
-
-	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->boost_off_cmds,
-		"qcom,mdss-dsi-boost-off-command", "qcom,mdss-dsi-boost-off-command-state");
+		"qcom,mdss-dsi-idle-off-command", "qcom,mdss-dsi-off-command-state");
 
 	rc = of_property_read_u32(np, "qcom,adjust-timer-wakeup-ms", &tmp);
 	pinfo->adjust_timer_delay_ms = (!rc ? tmp : 0);
@@ -2663,7 +2447,7 @@ static int mdss_panel_parse_dt(struct device_node *np,
 		bridge_chip_name = of_get_property(np,
 			"qcom,bridge-name", &len);
 		if (!bridge_chip_name || len <= 0) {
-			pr_err("%s:%d Unable to read qcom,bridge_name, data=%pK,len=%d\n",
+			pr_err("%s:%d Unable to read qcom,bridge_name, data=%p,len=%d\n",
 				__func__, __LINE__, bridge_chip_name, len);
 			rc = -EINVAL;
 			goto error;
@@ -2678,12 +2462,51 @@ error:
 	return -EINVAL;
 }
 
+#ifdef CONFIG_ASUS_BACKLIGHT_DEBUG
+static int brightness_lock_dbgfs_show(struct seq_file *s, void *unused)
+{
+    seq_printf(s, "%s: %d\n","success", brightness_lock);
+    return 0;
+}
+
+static int brightness_lock_dbgfs_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, brightness_lock_dbgfs_show, NULL);
+}
+
+static int brightness_lock_dbgfs_write(struct file *file,
+            const char __user *buf, size_t count, loff_t *ppos)
+{
+    char temp[32];
+    size_t buf_size;
+
+    buf_size = min(count, (sizeof(temp)-1));
+    if (copy_from_user(temp, buf, buf_size))
+        return -EFAULT;
+    switch (temp[0]) {
+    case '0':
+        brightness_lock=0;
+        break;
+    case '1':
+        brightness_lock=1;
+        break;
+    }
+
+    return count;
+}
+
+static const struct file_operations brightness_lock_debug_fops = {
+    .open = brightness_lock_dbgfs_open,
+    .read = seq_read,
+    .write = brightness_lock_dbgfs_write
+};
+#endif
+
 int mdss_dsi_panel_init(struct device_node *node,
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata,
 	int ndx)
 {
 	int rc = 0;
-	u32 tmp = 0;
 	static const char *panel_name;
 	struct mdss_panel_info *pinfo;
 
@@ -2704,13 +2527,6 @@ int mdss_dsi_panel_init(struct device_node *node,
 		pr_info("%s: Panel Name = %s\n", __func__, panel_name);
 		strlcpy(&pinfo->panel_name[0], panel_name, MDSS_MAX_PANEL_LEN);
 	}
-	/*read panel signature*/
-	rc = of_property_read_u32(node, "qcom,mdss-dsi-panel-signature", &tmp);
-	if (rc) {
-		pr_info("%s:%d, panel signature not specified\n", __func__, __LINE__);
-	}
-	pinfo->signature = (!rc ? tmp : 0);
-
 	rc = mdss_panel_parse_dt(node, ctrl_pdata);
 	if (rc) {
 		pr_err("%s:%d panel dt parse failed\n", __func__, __LINE__);
@@ -2725,19 +2541,14 @@ int mdss_dsi_panel_init(struct device_node *node,
 	ctrl_pdata->post_panel_on = mdss_dsi_post_panel_on;
 	ctrl_pdata->off = mdss_dsi_panel_off;
 	ctrl_pdata->low_power_config = mdss_dsi_panel_low_power_config;
-	ctrl_pdata->boost_mode_config= mdss_dsi_panel_boost_config;
 	ctrl_pdata->panel_data.set_backlight = mdss_dsi_panel_bl_ctrl;
 	ctrl_pdata->switch_mode = mdss_dsi_panel_switch_mode;
-	ctrl_pdata->panel_data.set_idle = mdss_dsi_panel_set_idle_mode;
-	ctrl_pdata->panel_data.get_idle = mdss_dsi_panel_get_idle_mode;
-	ctrl_pdata->set_acl = mdss_dsi_panel_acl_dcs;
-
-	ctrl_pdata->idle = 0;
-	ctrl_pdata->ulps_mode = 0;
-	ctrl_pdata->acl_enable = false;
-	INIT_WORK(&ctrl_pdata->idle_on_work, idle_on_work);
-	wake_lock_init(&ctrl_pdata->idle_on_wakelock, WAKE_LOCK_SUSPEND,
-                        "IDLE_ON_WAKELOCK");
+
+#ifdef CONFIG_ASUS_BACKLIGHT_DEBUG
+    (void)debugfs_create_file("brightness_lock",\
+                S_IRUGO | S_IWUSR | S_IWGRP,\
+                NULL, NULL, &brightness_lock_debug_fops);
+#endif
 
 	return 0;
 }
diff --git a/drivers/video/msm/mdss/mdss_dsi_status.c b/drivers/video/msm/mdss/mdss_dsi_status.c
index 1101cff66ad..bf545ae311f 100644
--- a/drivers/video/msm/mdss/mdss_dsi_status.c
+++ b/drivers/video/msm/mdss/mdss_dsi_status.c
@@ -24,7 +24,6 @@
 #include <linux/kobject.h>
 #include <linux/string.h>
 #include <linux/sysfs.h>
-#include <linux/interrupt.h>
 
 #include "mdss_fb.h"
 #include "mdss_dsi.h"
@@ -95,10 +94,8 @@ irqreturn_t hw_vsync_handler(int irq, void *data)
 	else
 		pr_err("Pstatus data is NULL\n");
 
-	if (!atomic_read(&ctrl_pdata->te_irq_ready)) {
-		complete_all(&ctrl_pdata->te_irq_comp);
+	if (!atomic_read(&ctrl_pdata->te_irq_ready))
 		atomic_inc(&ctrl_pdata->te_irq_ready);
-	}
 
 	return IRQ_HANDLED;
 }
@@ -163,12 +160,10 @@ static int fb_event_callback(struct notifier_block *self,
 			schedule_delayed_work(&pdata->check_status,
 				msecs_to_jiffies(interval));
 			break;
-		case FB_BLANK_VSYNC_SUSPEND:
-		case FB_BLANK_NORMAL:
-			pr_info("%s : ESD thread running\n", __func__);
-			break;
 		case FB_BLANK_POWERDOWN:
 		case FB_BLANK_HSYNC_SUSPEND:
+		case FB_BLANK_VSYNC_SUSPEND:
+		case FB_BLANK_NORMAL:
 			cancel_delayed_work(&pdata->check_status);
 			break;
 		default:
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
old mode 100755
new mode 100644
index 14ec13485f2..cebff31b231
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -54,8 +54,6 @@
 #include "mdss_debug.h"
 #include "mdss_smmu.h"
 #include "mdss_mdp.h"
-#include "mdss_dsi.h"
-
 
 #ifdef CONFIG_FB_MSM_TRIPLE_BUFFER
 #define MDSS_FB_NUM 3
@@ -77,13 +75,9 @@
 #define BLANK_FLAG_ULP	FB_BLANK_NORMAL
 #endif
 
-#define BUFF_LEN   10
-
 static struct fb_info *fbi_list[MAX_FBI_LIST];
 static int fbi_list_index;
 
-static void *panel_lk_addr = NULL;
-
 static u32 mdss_fb_pseudo_palette[16] = {
 	0x00000000, 0xffffffff, 0xffffffff, 0xffffffff,
 	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
@@ -767,548 +761,6 @@ static ssize_t mdss_fb_get_dfps_mode(struct device *dev,
 	return ret;
 }
 
-static ssize_t mdss_fb_set_idle_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data *pdata;
-	int rc = 0;
-	int idle_mode = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-
-	rc = kstrtoint(buf, 10, &idle_mode);
-	if (rc) {
-		pr_err("kstrtoint failed. rc=%d\n", rc);
-		return rc;
-	}
-
-	pr_debug("Idle mode = %d\n", idle_mode);
-
-	if (mfd->index == 0) {
-		if (ctrl_pdata && ctrl_pdata->low_power_config)
-			ctrl_pdata->low_power_config(pdata, idle_mode);
-	}
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_display_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x0a, 0x00,
-				NULL, rx_buf, 1);
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);
-
-	kfree(rx_buf);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_get_panel_signature(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-
-	ret = scnprintf(buf, PAGE_SIZE, "%d\n",pinfo->signature);
-
-	return ret;
-}
-static ssize_t mdss_fb_set_ulps_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data *pdata;
-	int rc = 0;
-	int ulps_mode = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-
-	rc = kstrtoint(buf, 10, &ulps_mode);
-	if (rc) {
-		pr_err("kstrtoint failed. rc=%d\n", rc);
-		return rc;
-	}
-
-	pr_err("ulpm_mode = %d\n", ulps_mode);
-
-	if(ulps_mode == 1){
-		ctrl_pdata->ulps_mode = 1;
-		mfd->ulps_fmode = true;
-	}
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_lk_info(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	uint32_t read_val = 0;
-	int ret = 0;
-
-	if(panel_lk_addr){
-		read_val = __raw_readl(panel_lk_addr);
-		pr_err("The read value is 0x%02x",read_val);
-	}
-	else
-		pr_err("There is no error info\n");
-
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",read_val);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_set_boost_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data *pdata;
-	int rc = 0;
-	int boost_mode = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-
-	rc = kstrtoint(buf, 10, &boost_mode);
-	if (rc) {
-		pr_err("kstrtoint failed. rc=%d\n", rc);
-		return rc;
-	}
-
-	pr_err("boost_mode = %d\n", boost_mode);
-
-	if (mfd->index == 0) {
-		if (ctrl_pdata && ctrl_pdata->boost_mode_config)
-			ctrl_pdata->boost_mode_config(pdata, boost_mode);
-	}
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_acl_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data *pdata = NULL;
-	int rc = -1;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if ( NULL == pdata )
-	{
-		pr_err("%s pdata failed. rc=%d\n", __func__,rc);
-		return rc;
-	}
-
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	if ( NULL == ctrl_pdata )
-	{
-		pr_err("%s ctrl_pdate failed. rc=%d\n",__func__, rc);
-		return rc;
-	}
-
-	rc = scnprintf(buf, PAGE_SIZE, "%d\n",ctrl_pdata->acl_enable);
-
-	return rc;
-}
-
-static ssize_t mdss_fb_set_acl_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data *pdata = NULL;
-	int rc = 0;
-	int acl_enable = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if ( NULL == pdata )
-	{
-		rc = -1;
-		pr_err("%s pdata failed. rc=%d\n", __func__,rc);
-		return rc;
-	}
-
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	if ( NULL == ctrl_pdata )
-	{
-		rc = -1;
-		pr_err("%s ctrl_pdate failed. rc=%d\n",__func__, rc);
-		return rc;
-	}
-
-	rc = kstrtoint(buf, BUFF_LEN , &acl_enable);
-	if (rc)
-	{
-		pr_err("kstrtoint failed. rc=%d\n", rc);
-		return rc;
-	}
-
-	pr_err("acl_mode = %d\n", acl_enable);
-
-	if ( 0 == mfd->index )
-	{
-		if (ctrl_pdata && ctrl_pdata->set_acl)
-		{
-			ctrl_pdata->acl_enable = acl_enable;
-			//effect acl feature in unblank state
-			ctrl_pdata->set_acl(pdata, acl_enable);
-		}
-	}
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_image_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);//malloc 2 bytes buffer
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x0d, 0x00,
-				NULL, rx_buf, 1);//read image mode
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);
-
-	kfree(rx_buf);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_set_image_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data* pdata;
-	struct mdss_panel_info* pinfo;
-	struct mdss_dsi_ctrl_pdata* ctrl_pdata = NULL;
-	struct dcs_cmd_req cmdreq;
-	static char cmd[2] = {0x13, 0x00};//normal mode cmd
-	static struct dsi_cmd_desc dsi_cmd = {
-		{DTYPE_DCS_WRITE, 1, 0, 0, 1, sizeof(cmd)},cmd};
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata, panel_data);
-
-	memset(&cmdreq, 0, sizeof(cmdreq));
-	cmdreq.cmds = &dsi_cmd;
-	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
-	cmdreq.rlen = 0;
-	cmdreq.cb = NULL;
-
-	mdss_dsi_cmdlist_put(ctrl_pdata, &cmdreq);
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_pixel_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);//malloc 2 bytes buffer
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x0c, 0x00,
-				NULL, rx_buf, 1);//read pixel mode
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);
-
-	kfree(rx_buf);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_set_pixel_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data* pdata;
-	struct mdss_panel_info* pinfo;
-	struct mdss_dsi_ctrl_pdata* ctrl_pdata = NULL;
-	struct dcs_cmd_req cmdreq;
-	static char cmd[2] = {0x22, 0x00};//all pixel off cmd
-	static struct dsi_cmd_desc dsi_cmd = {
-		{DTYPE_DCS_WRITE, 1, 0, 0, 1, sizeof(cmd)},cmd};
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata, panel_data);
-
-	memset(&cmdreq, 0, sizeof(cmdreq));
-	cmdreq.cmds = &dsi_cmd;
-	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
-	cmdreq.rlen = 0;
-	cmdreq.cb = NULL;
-
-	mdss_dsi_cmdlist_put(ctrl_pdata, &cmdreq);
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_signal_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);//malloc 2 bytes buffer
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x0e, 0x00,
-				NULL, rx_buf, 1);
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);//read signal mode
-
-	kfree(rx_buf);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_get_bright_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);//malloc 2 bytes buffer
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x52, 0x00,
-				NULL, rx_buf, 1);//read bright mode
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);
-
-	kfree(rx_buf);
-
-	return ret;
-}
-
-static ssize_t mdss_fb_set_bright_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = fbi->par;
-	struct mdss_panel_data* pdata;
-	struct mdss_panel_info* pinfo;
-	struct mdss_dsi_ctrl_pdata* ctrl_pdata = NULL;
-	struct dcs_cmd_req cmdreq;
-	static char cmd[2] = {0x51, 0xff};//set brightness to max cmd
-	static struct dsi_cmd_desc dsi_cmd = {
-		{DTYPE_DCS_WRITE1, 1, 0, 0, 1, sizeof(cmd)},cmd};
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata, panel_data);
-
-	memset(&cmdreq, 0, sizeof(cmdreq));
-	cmdreq.cmds = &dsi_cmd;
-	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
-	cmdreq.rlen = 0;
-	cmdreq.cb = NULL;
-
-	mdss_dsi_cmdlist_put(ctrl_pdata, &cmdreq);
-
-	return count;
-}
-
-static ssize_t mdss_fb_get_bright_en_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
-	struct mdss_panel_data *pdata;
-	struct mdss_panel_info *pinfo;
-	int ret = 0;
-	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
-	char *rx_buf = NULL;
-
-	if ((!dev) || (!attr) || (!buf))
-	{
-		pr_err("dev attr buf NULL!\n");
-		return -EINVAL;
-	}
-	pdata = dev_get_platdata(&mfd->pdev->dev);
-	if (!pdata) {
-		pr_err("no panel connected!\n");
-		return -EINVAL;
-	}
-	pinfo = &pdata->panel_info;
-	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
-				panel_data);
-	rx_buf= kzalloc(2, GFP_KERNEL);//malloc 2 bytes buffer
-	if (!rx_buf) {
-		pr_err("not enough memory to hold panel reg dump\n");
-		return -ENOMEM;;
-	}
-	mdss_dsi_panel_cmd_read(ctrl_pdata, 0x54, 0x00,
-				NULL, rx_buf, 1);//read bright enable mode
-	ret = scnprintf(buf, PAGE_SIZE, "0x%02x\n",rx_buf[0]);
-
-	kfree(rx_buf);
-
-	return ret;
-}
 static DEVICE_ATTR(msm_fb_type, S_IRUGO, mdss_fb_get_type, NULL);
 static DEVICE_ATTR(msm_fb_split, S_IRUGO | S_IWUSR, mdss_fb_show_split,
 					mdss_fb_store_split);
@@ -1325,18 +777,6 @@ static DEVICE_ATTR(msm_fb_panel_status, S_IRUGO | S_IWUSR,
 	mdss_fb_get_panel_status, mdss_fb_force_panel_dead);
 static DEVICE_ATTR(msm_fb_dfps_mode, S_IRUGO | S_IWUSR,
 	mdss_fb_get_dfps_mode, mdss_fb_change_dfps_mode);
-static DEVICE_ATTR(idle_mode, S_IRUGO | S_IWUSR | S_IWGRP, NULL, mdss_fb_set_idle_mode);
-static DEVICE_ATTR(display_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_display_mode, NULL);
-static DEVICE_ATTR(panel_signature, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_panel_signature, NULL);
-static DEVICE_ATTR(ulps_mode, S_IRUGO | S_IWUSR | S_IWGRP, NULL, mdss_fb_set_ulps_mode);
-static DEVICE_ATTR(boost_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_lk_info, mdss_fb_set_boost_mode);
-static DEVICE_ATTR(acl_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_acl_mode, mdss_fb_set_acl_mode);
-static DEVICE_ATTR(image_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_image_mode, mdss_fb_set_image_mode);
-static DEVICE_ATTR(pixel_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_pixel_mode, mdss_fb_set_pixel_mode);
-static DEVICE_ATTR(signal_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_signal_mode, NULL);
-static DEVICE_ATTR(bright_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_bright_mode, mdss_fb_set_bright_mode);
-static DEVICE_ATTR(bright_en_mode, S_IRUGO | S_IWUSR | S_IWGRP, mdss_fb_get_bright_en_mode, NULL);
-
 static struct attribute *mdss_fb_attrs[] = {
 	&dev_attr_msm_fb_type.attr,
 	&dev_attr_msm_fb_split.attr,
@@ -1348,17 +788,6 @@ static struct attribute *mdss_fb_attrs[] = {
 	&dev_attr_msm_fb_thermal_level.attr,
 	&dev_attr_msm_fb_panel_status.attr,
 	&dev_attr_msm_fb_dfps_mode.attr,
-	&dev_attr_idle_mode.attr,
-	&dev_attr_display_mode.attr,
-	&dev_attr_panel_signature.attr,
-	&dev_attr_ulps_mode.attr,
-	&dev_attr_boost_mode.attr,
-	&dev_attr_acl_mode.attr,
-	&dev_attr_image_mode.attr,
-	&dev_attr_pixel_mode.attr,
-	&dev_attr_signal_mode.attr,
-	&dev_attr_bright_mode.attr,
-	&dev_attr_bright_en_mode.attr,
 	NULL,
 };
 
@@ -1618,7 +1047,6 @@ static int mdss_fb_probe(struct platform_device *pdev)
 	struct mdss_panel_data *pdata;
 	struct fb_info *fbi;
 	int rc;
-	struct device_node *np;
 
 	if (fbi_list_index >= MAX_FBI_LIST)
 		return -ENOMEM;
@@ -1663,7 +1091,6 @@ static int mdss_fb_probe(struct platform_device *pdev)
 	mfd->ad_bl_level = 0;
 	mfd->fb_imgType = MDP_RGBA_8888;
 	mfd->calib_mode_bl = 0;
-	mfd->ulps_fmode = false;
 
 	mfd->pdev = pdev;
 
@@ -1777,18 +1204,6 @@ static int mdss_fb_probe(struct platform_device *pdev)
 
 	INIT_DELAYED_WORK(&mfd->idle_notify_work, __mdss_fb_idle_notify_work);
 
-	np = of_find_compatible_node(NULL, NULL,
-				"qcom,msm-imem-panel_log_lk");
-
-	if (!np) {
-		pr_err("unable to find panel_lk_addr\n");
-	} else {
-		panel_lk_addr = of_iomap(np, 0);
-		if (!panel_lk_addr) {
-			pr_err("unable to map panel_lk_addr\n");
-		}
-	}
-
 	return rc;
 }
 
@@ -1831,7 +1246,6 @@ static int mdss_fb_remove(struct platform_device *pdev)
 		return -EINVAL;
 
 	mdss_fb_unregister_input_handler(mfd);
-	mdss_panel_debugfs_cleanup(mfd->panel_info);
 
 	if (mdss_fb_suspend_sub(mfd))
 		pr_err("msm_fb_remove: can't stop the device %d\n",
@@ -2050,7 +1464,6 @@ static struct platform_driver mdss_fb_driver = {
 	.driver = {
 		.name = "mdss_fb",
 		.of_match_table = mdss_fb_dt_match,
-		.pm = &mdss_fb_pm_ops,
 	},
 };
 
@@ -2614,7 +2027,7 @@ int mdss_fb_alloc_fb_ion_memory(struct msm_fb_data_type *mfd, size_t fb_size)
 		rc = PTR_ERR(vaddr);
 		goto err_unmap;
 	}
-	pr_debug("alloc 0x%zuB vaddr = %pK for fb%d\n", fb_size,
+	pr_debug("alloc 0x%zuB vaddr = %p for fb%d\n", fb_size,
 			vaddr, mfd->index);
 
 	mfd->fbi->screen_base = (char *) vaddr;
@@ -2713,7 +2126,7 @@ static int mdss_fb_fbmem_ion_mmap(struct fb_info *info,
 				vma->vm_page_prot =
 					pgprot_writecombine(vma->vm_page_prot);
 
-			pr_debug("vma=%pK, addr=%x len=%ld\n",
+			pr_debug("vma=%p, addr=%x len=%ld\n",
 					vma, (unsigned int)addr, len);
 			pr_debug("vm_start=%x vm_end=%x vm_page_prot=%ld\n",
 					(unsigned int)vma->vm_start,
@@ -2880,7 +2293,7 @@ static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
 		return -ERANGE;
 	}
 
-	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%pK virt) (%pa iova) for fb%d\n",
+	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%p virt) (%pa iova) for fb%d\n",
 		 size, &phys, virt, &mfd->iova, mfd->index);
 
 	mfd->fbi->screen_base = virt;
@@ -3168,7 +2581,7 @@ static int mdss_fb_open(struct fb_info *info, int user)
 	}
 
 	mfd->ref_cnt++;
-	pr_debug("mfd refcount:%d file:%pK\n", mfd->ref_cnt, info->file);
+	pr_debug("mfd refcount:%d file:%p\n", mfd->ref_cnt, info->file);
 
 	return 0;
 
@@ -3233,7 +2646,7 @@ static int mdss_fb_release_all(struct fb_info *info, bool release_all)
 		pr_warn("file node not found or wrong ref cnt: release all:%d refcnt:%d\n",
 			release_all, mfd->ref_cnt);
 
-	pr_debug("current process=%s pid=%d mfd->ref=%d file:%pK\n",
+	pr_debug("current process=%s pid=%d mfd->ref=%d file:%p\n",
 		task->comm, current->tgid, mfd->ref_cnt, info->file);
 
 	if (!mfd->ref_cnt || release_all) {
@@ -3357,12 +2770,9 @@ static int __mdss_fb_wait_for_fence_sub(struct msm_sync_pt_data *sync_pt_data,
 
 			pr_warn("%s: sync_fence_wait timed out! ",
 					sync_pt_data->fence_name);
-			pr_warn("%s: sync_fence_wait timed out! ",
-					fences[i]->name);
 			pr_cont("Waiting %ld.%ld more seconds\n",
 				(wait_ms/MSEC_PER_SEC), (wait_ms%MSEC_PER_SEC));
-			MDSS_XLOG(sync_pt_data->timeline_value);
-			MDSS_XLOG_TOUT_HANDLER("mdp");
+
 			ret = sync_fence_wait(fences[i], wait_ms);
 
 			if (ret == -ETIME)
@@ -3408,7 +2818,6 @@ void mdss_fb_signal_timeline(struct msm_sync_pt_data *sync_pt_data)
 	if (atomic_add_unless(&sync_pt_data->commit_cnt, -1, 0) &&
 			sync_pt_data->timeline) {
 		sw_sync_timeline_inc(sync_pt_data->timeline, 1);
-		MDSS_XLOG(sync_pt_data->timeline_value);
 		sync_pt_data->timeline_value++;
 
 		pr_debug("%s: buffer signaled! timeline val=%d remaining=%d\n",
@@ -3773,7 +3182,7 @@ int mdss_fb_atomic_commit(struct fb_info *info,
 
 	if (!mfd || (!mfd->op_enable)) {
 		pr_err("mfd is NULL or operation not permitted\n");
-		return -EPERM;
+		goto end;
 	}
 
 	if ((mdss_fb_is_power_off(mfd)) &&
@@ -4026,11 +3435,9 @@ static int __mdss_fb_perform_commit(struct msm_fb_data_type *mfd)
 			mfd->pending_switch = false;
 	}
 	if (fb_backup->disp_commit.flags & MDP_DISPLAY_COMMIT_OVERLAY) {
-		if (mfd->mdp.kickoff_fnc && !mfd->ulps_fmode)
+		if (mfd->mdp.kickoff_fnc)
 			ret = mfd->mdp.kickoff_fnc(mfd,
 					&fb_backup->disp_commit);
-		else if(mfd->ulps_fmode)
-			pr_debug("going to ULPS mode\n");
 		else
 			pr_warn("no kickoff function setup for fb%d\n",
 					mfd->index);
@@ -4640,10 +4047,6 @@ static int mdss_fb_handle_buf_sync_ioctl(struct msm_sync_pt_data *sync_pt_data,
 	val = sync_pt_data->timeline_value + sync_pt_data->threshold +
 			atomic_read(&sync_pt_data->commit_cnt);
 
-	MDSS_XLOG(sync_pt_data->timeline_value, val,
-		atomic_read(&sync_pt_data->commit_cnt));
-	pr_debug("%s: fence CTL%d Commit_cnt%d\n", sync_pt_data->fence_name,
-		sync_pt_data->timeline_value,  atomic_read(&sync_pt_data->commit_cnt));
 	/* Set release fence */
 	rel_fence = mdss_fb_sync_get_fence(sync_pt_data->timeline,
 			sync_pt_data->fence_name, val);
@@ -4837,7 +4240,7 @@ static int mdss_fb_atomic_commit_ioctl(struct fb_info *info,
 			ret = copy_from_user(scale, layer->scale,
 					sizeof(struct mdp_scale_data));
 			if (ret) {
-				pr_err("layer list copy from user failed, scale = %pK\n",
+				pr_err("layer list copy from user failed, scale = %p\n",
 						layer->scale);
 				kfree(scale);
 				scale = NULL;
@@ -4988,7 +4391,6 @@ static int __ioctl_wait_idle(struct msm_fb_data_type *mfd, u32 cmd)
 {
 	int ret = 0;
 
-#ifndef TARGET_HW_MDSS_MDP3
 	if (mfd->wait_for_kickoff &&
 		((cmd == MSMFB_OVERLAY_PREPARE) ||
 		(cmd == MSMFB_BUFFER_SYNC) ||
@@ -5001,16 +4403,7 @@ static int __ioctl_wait_idle(struct msm_fb_data_type *mfd, u32 cmd)
 		(cmd == MSMFB_OVERLAY_SET))) {
 		ret = mdss_fb_wait_for_kickoff(mfd);
 	}
-#else
-	if ((cmd != MSMFB_VSYNC_CTRL) &&
-		(cmd != MSMFB_OVERLAY_VSYNC_CTRL) &&
-		(cmd != MSMFB_ASYNC_BLIT) &&
-		(cmd != MSMFB_BLIT) &&
-		(cmd != MSMFB_NOTIFY_UPDATE) &&
-		(cmd != MSMFB_OVERLAY_PREPARE)) {
-		ret = mdss_fb_wait_for_kickoff(mfd);
-	}
-#endif
+
 	if (ret && (ret != -ESHUTDOWN))
 		pr_err("wait_idle failed. cmd=0x%x rc=%d\n", cmd, ret);
 
diff --git a/drivers/video/msm/mdss/mdss_fb.h b/drivers/video/msm/mdss/mdss_fb.h
index 27892dbbd24..02ab4289d5d 100644
--- a/drivers/video/msm/mdss/mdss_fb.h
+++ b/drivers/video/msm/mdss/mdss_fb.h
@@ -360,7 +360,6 @@ struct msm_fb_data_type {
 	bool pending_switch;
 	struct mutex switch_lock;
 	struct input_handler *input_handler;
-	bool ulps_fmode;
 };
 
 static inline void mdss_fb_update_notify_update(struct msm_fb_data_type *mfd)
diff --git a/drivers/video/msm/mdss/mdss_hdmi_tx.c b/drivers/video/msm/mdss/mdss_hdmi_tx.c
index b234d1e651c..a4545ad41ab 100644
--- a/drivers/video/msm/mdss/mdss_hdmi_tx.c
+++ b/drivers/video/msm/mdss/mdss_hdmi_tx.c
@@ -1458,7 +1458,7 @@ static int hdmi_tx_sysfs_create(struct hdmi_tx_ctrl *hdmi_ctrl,
 		return rc;
 	}
 	hdmi_ctrl->kobj = &fbi->dev->kobj;
-	DEV_DBG("%s: sysfs group %pK\n", __func__, hdmi_ctrl->kobj);
+	DEV_DBG("%s: sysfs group %p\n", __func__, hdmi_ctrl->kobj);
 
 	return 0;
 } /* hdmi_tx_sysfs_create */
@@ -4790,7 +4790,7 @@ static int hdmi_tx_init_resource(struct hdmi_tx_ctrl *hdmi_ctrl)
 			DEV_DBG("%s: '%s' remap failed or not available\n",
 				__func__, hdmi_tx_io_name(i));
 		}
-		DEV_INFO("%s: '%s': start = 0x%pK, len=0x%x\n", __func__,
+		DEV_INFO("%s: '%s': start = 0x%p, len=0x%x\n", __func__,
 			hdmi_tx_io_name(i), pdata->io[i].base,
 			pdata->io[i].len);
 	}
@@ -5065,7 +5065,7 @@ static int hdmi_tx_get_dt_vreg_data(struct device *dev,
 				__func__, hdmi_tx_pm_name(module_type), rc);
 			goto error;
 		}
-		mp->vreg_config[j].load[DSS_REG_MODE_ENABLE] = val_array[i];
+		mp->vreg_config[j].enable_load = val_array[i];
 
 		memset(val_array, 0, sizeof(u32) * dt_vreg_total);
 		rc = of_property_read_u32_array(of_node,
@@ -5076,15 +5076,15 @@ static int hdmi_tx_get_dt_vreg_data(struct device *dev,
 				__func__, hdmi_tx_pm_name(module_type), rc);
 			goto error;
 		}
-		mp->vreg_config[j].load[DSS_REG_MODE_DISABLE] = val_array[i];
+		mp->vreg_config[j].disable_load = val_array[i];
 
 		DEV_DBG("%s: %s min=%d, max=%d, enable=%d disable=%d\n",
 			__func__,
 			mp->vreg_config[j].vreg_name,
 			mp->vreg_config[j].min_voltage,
 			mp->vreg_config[j].max_voltage,
-			mp->vreg_config[j].load[DSS_REG_MODE_ENABLE],
-			mp->vreg_config[j].load[DSS_REG_MODE_DISABLE]);
+			mp->vreg_config[j].enable_load,
+			mp->vreg_config[j].disable_load);
 
 		ndx_mask >>= 1;
 		j++;
@@ -5298,7 +5298,7 @@ static int hdmi_tx_get_dt_data(struct platform_device *pdev,
 
 	data = of_get_property(pdev->dev.of_node, "qcom,display-id", &len);
 	if (!data || len <= 0)
-		pr_err("%s:%d Unable to read qcom,display-id, data=%pK,len=%d\n",
+		pr_err("%s:%d Unable to read qcom,display-id, data=%p,len=%d\n",
 			__func__, __LINE__, data, len);
 	else
 		snprintf(hdmi_ctrl->panel_data.panel_info.display_id,
diff --git a/drivers/video/msm/mdss/mdss_io_util.c b/drivers/video/msm/mdss/mdss_io_util.c
index c1852fd8b35..28889888480 100644
--- a/drivers/video/msm/mdss/mdss_io_util.c
+++ b/drivers/video/msm/mdss/mdss_io_util.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -211,52 +211,6 @@ vreg_get_fail:
 } /* msm_dss_config_vreg */
 EXPORT_SYMBOL(msm_dss_config_vreg);
 
-int msm_dss_config_vreg_opt_mode(struct dss_vreg *in_vreg, int num_vreg,
-				 enum dss_vreg_mode mode)
-{
-	int i = 0, rc = 0;
-
-	if (mode >= DSS_REG_MODE_MAX) {
-		pr_err("%pS->%s: invalid mode %d\n",
-			 __builtin_return_address(0), __func__, mode);
-		rc = -EINVAL;
-		goto error;
-	}
-
-	for (i = 0; i < num_vreg; i++) {
-		rc = PTR_RET(in_vreg[i].vreg);
-		if (rc) {
-			DEV_ERR("%pS->%s: %s regulator error. rc=%d\n",
-				__builtin_return_address(0), __func__,
-				in_vreg[i].vreg_name, rc);
-			goto error;
-		}
-
-		DEV_DBG("%s: Setting optimum mode %d for %s (load=%d)\n",
-			__func__, mode, in_vreg[i].vreg_name,
-			in_vreg[i].load[mode]);
-		rc = regulator_set_optimum_mode(in_vreg[i].vreg,
-					in_vreg[i].load[mode]);
-		if (rc < 0) {
-			DEV_ERR("%pS->%s: %s set opt mode failed. rc=%d\n",
-				__builtin_return_address(0), __func__,
-				in_vreg[i].vreg_name, rc);
-			goto error;
-		} else {
-			/*
-			 * regulator_set_optimum_mode can return non-zero
-			 * value for success. However, this API is expected
-			 * to return 0 for success.
-			 */
-			rc = 0;
-		}
-	}
-
-error:
-	return rc;
-}
-EXPORT_SYMBOL(msm_dss_config_vreg_opt_mode);
-
 int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg, int enable)
 {
 	int i = 0, rc = 0;
@@ -275,7 +229,7 @@ int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg, int enable)
 				usleep_range(in_vreg[i].pre_on_sleep * 1000,
 					in_vreg[i].pre_on_sleep * 1000);
 			rc = regulator_set_optimum_mode(in_vreg[i].vreg,
-				in_vreg[i].load[DSS_REG_MODE_ENABLE]);
+				in_vreg[i].enable_load);
 			if (rc < 0) {
 				DEV_ERR("%pS->%s: %s set opt m fail\n",
 					__builtin_return_address(0), __func__,
@@ -299,7 +253,7 @@ int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg, int enable)
 				usleep_range(in_vreg[i].pre_off_sleep * 1000,
 					in_vreg[i].pre_off_sleep * 1000);
 			regulator_set_optimum_mode(in_vreg[i].vreg,
-				in_vreg[i].load[DSS_REG_MODE_DISABLE]);
+				in_vreg[i].disable_load);
 			regulator_disable(in_vreg[i].vreg);
 			if (in_vreg[i].post_off_sleep)
 				usleep_range(in_vreg[i].post_off_sleep * 1000,
@@ -309,7 +263,7 @@ int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg, int enable)
 	return rc;
 
 disable_vreg:
-	regulator_set_optimum_mode(in_vreg[i].vreg, in_vreg[i].load[DSS_REG_MODE_DISABLE]);
+	regulator_set_optimum_mode(in_vreg[i].vreg, in_vreg[i].disable_load);
 
 vreg_set_opt_mode_fail:
 	for (i--; i >= 0; i--) {
@@ -317,7 +271,7 @@ vreg_set_opt_mode_fail:
 			usleep_range(in_vreg[i].pre_off_sleep * 1000,
 				in_vreg[i].pre_off_sleep * 1000);
 		regulator_set_optimum_mode(in_vreg[i].vreg,
-			in_vreg[i].load[DSS_REG_MODE_DISABLE]);
+			in_vreg[i].disable_load);
 		regulator_disable(in_vreg[i].vreg);
 		if (in_vreg[i].post_off_sleep)
 			usleep_range(in_vreg[i].post_off_sleep * 1000,
diff --git a/drivers/video/msm/mdss/mdss_mdp.c b/drivers/video/msm/mdss/mdss_mdp.c
index 2b0bcec89d4..e7301ae8e6e 100644
--- a/drivers/video/msm/mdss/mdss_mdp.c
+++ b/drivers/video/msm/mdss/mdss_mdp.c
@@ -481,7 +481,7 @@ struct reg_bus_client *mdss_reg_bus_vote_client_create(char *client_name)
 	strlcpy(client->name, client_name, MAX_CLIENT_NAME_LEN);
 	client->usecase_ndx = VOTE_INDEX_DISABLE;
 	client->id = id;
-	pr_debug("bus vote client %s created:%pK id :%d\n", client_name,
+	pr_debug("bus vote client %s created:%p id :%d\n", client_name,
 		client, id);
 	id++;
 	list_add(&client->list, &mdss_res->reg_bus_clist);
@@ -495,7 +495,7 @@ void mdss_reg_bus_vote_client_destroy(struct reg_bus_client *client)
 	if (!client) {
 		pr_err("reg bus vote: invalid client handle\n");
 	} else {
-		pr_debug("bus vote client %s destroyed:%pK id:%u\n",
+		pr_debug("bus vote client %s destroyed:%p id:%u\n",
 			client->name, client, client->id);
 		mutex_lock(&mdss_res->reg_bus_lock);
 		list_del_init(&client->list);
@@ -1561,7 +1561,7 @@ static u32 mdss_mdp_res_init(struct mdss_data_type *mdata)
 
 	mdata->iclient = msm_ion_client_create(mdata->pdev->name);
 	if (IS_ERR_OR_NULL(mdata->iclient)) {
-		pr_err("msm_ion_client_create() return error (%pK)\n",
+		pr_err("msm_ion_client_create() return error (%p)\n",
 				mdata->iclient);
 		mdata->iclient = NULL;
 	}
@@ -2028,7 +2028,7 @@ static int mdss_mdp_probe(struct platform_device *pdev)
 	if (rc)
 		pr_debug("unable to map MDSS VBIF non-realtime base\n");
 	else
-		pr_debug("MDSS VBIF NRT HW Base addr=%pK len=0x%x\n",
+		pr_debug("MDSS VBIF NRT HW Base addr=%p len=0x%x\n",
 			mdata->vbif_nrt_io.base, mdata->vbif_nrt_io.len);
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
@@ -2923,7 +2923,7 @@ static int mdss_mdp_cdm_addr_setup(struct mdss_data_type *mdata,
 		head[i].base = (mdata->mdss_io.base) + cdm_offsets[i];
 		atomic_set(&head[i].kref.refcount, 0);
 		mutex_init(&head[i].lock);
-		pr_debug("%s: cdm off (%d) = %pK\n", __func__, i, head[i].base);
+		pr_debug("%s: cdm off (%d) = %p\n", __func__, i, head[i].base);
 	}
 
 	mdata->cdm_off = head;
@@ -2990,7 +2990,7 @@ static int mdss_mdp_dsc_addr_setup(struct mdss_data_type *mdata,
 	for (i = 0; i < len; i++) {
 		head[i].num = i;
 		head[i].base = (mdata->mdss_io.base) + dsc_offsets[i];
-		pr_debug("dsc off (%d) = %pK\n", i, head[i].base);
+		pr_debug("dsc off (%d) = %p\n", i, head[i].base);
 	}
 
 	mdata->dsc_off = head;
diff --git a/drivers/video/msm/mdss/mdss_mdp_ctl.c b/drivers/video/msm/mdss/mdss_mdp_ctl.c
index 63191fd2be5..0b77f921630 100644
--- a/drivers/video/msm/mdss/mdss_mdp_ctl.c
+++ b/drivers/video/msm/mdss/mdss_mdp_ctl.c
@@ -901,7 +901,7 @@ int mdss_mdp_perf_calc_pipe(struct mdss_mdp_pipe *pipe,
 	prefill_params.is_hflip = pipe->flags & MDP_FLIP_LR;
 	prefill_params.is_cmd = !mixer->ctl->is_video_mode;
 	prefill_params.pnum = pipe->num;
-	prefill_params.is_ubwc = mdss_mdp_is_ubwc_format(pipe->src_fmt);
+	prefill_params.is_bwc = mdss_mdp_is_ubwc_format(pipe->src_fmt);
 	prefill_params.is_nv12 = mdss_mdp_is_nv12_format(pipe->src_fmt);
 
 	mdss_mdp_get_bw_vote_mode(mixer, mdata->mdp_rev, perf,
@@ -4032,17 +4032,15 @@ void mdss_mdp_set_roi(struct mdss_mdp_ctl *ctl,
 	}
 
 	previous_frame_pu_type = mdss_mdp_get_pu_type(ctl);
-	if (ctl->mixer_left) {
-		mdss_mdp_set_mixer_roi(ctl->mixer_left, l_roi);
-		ctl->roi = ctl->mixer_left->roi;
-	}
+	mdss_mdp_set_mixer_roi(ctl->mixer_left, l_roi);
+	ctl->roi = ctl->mixer_left->roi;
 
 	if (ctl->mfd->split_mode == MDP_DUAL_LM_DUAL_DISPLAY) {
 		struct mdss_mdp_ctl *sctl = mdss_mdp_get_split_ctl(ctl);
 
-		if (sctl && sctl->mixer_left) {
-				mdss_mdp_set_mixer_roi(sctl->mixer_left, r_roi);
-				sctl->roi = sctl->mixer_left->roi;
+		if (sctl) {
+			mdss_mdp_set_mixer_roi(sctl->mixer_left, r_roi);
+			sctl->roi = sctl->mixer_left->roi;
 		}
 	} else if (is_dual_lm_single_display(ctl->mfd) && ctl->mixer_right) {
 
@@ -4052,7 +4050,7 @@ void mdss_mdp_set_roi(struct mdss_mdp_ctl *ctl,
 		ctl->roi.w += ctl->mixer_right->roi.w;
 
 		/* right_only, update roi.x as per CTL ROI guidelines */
-		if (ctl->mixer_left && !ctl->mixer_left->valid_roi) {
+		if (!ctl->mixer_left->valid_roi) {
 			ctl->roi = ctl->mixer_right->roi;
 			ctl->roi.x = left_lm_w_from_mfd(ctl->mfd) +
 				ctl->mixer_right->roi.x;
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
index cd1f02bd075..ba13444c38b 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
@@ -1549,7 +1549,7 @@ static int mdss_mdp_cmd_wait4pingpong(struct mdss_mdp_ctl *ctl, void *arg)
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt), ctl->roi_bkup.w,
 			ctl->roi_bkup.h);
 
-	pr_debug("%s: intf_num=%d ctx=%pK koff_cnt=%d\n", __func__,
+	pr_debug("%s: intf_num=%d ctx=%p koff_cnt=%d\n", __func__,
 			ctl->intf_num, ctx, atomic_read(&ctx->koff_cnt));
 
 	rc = wait_event_timeout(ctx->pp_waitq,
@@ -1777,7 +1777,7 @@ int mdss_mdp_cmd_set_autorefresh_mode(struct mdss_mdp_ctl *mctl, int frame_cnt)
 	struct mdss_panel_info *pinfo;
 
 	if (!mctl || !mctl->is_master || !mctl->panel_data) {
-		pr_err("invalid ctl mctl:%pK pdata:%pK\n",
+		pr_err("invalid ctl mctl:%p pdata:%p\n",
 			mctl, mctl ? mctl->panel_data : 0);
 		return -ENODEV;
 	}
@@ -2782,7 +2782,7 @@ static int mdss_mdp_cmd_ctx_setup(struct mdss_mdp_ctl *ctl,
 
 	ctx->intf_stopped = 0;
 
-	pr_debug("%s: ctx=%pK num=%d aux=%d\n", __func__, ctx,
+	pr_debug("%s: ctx=%p num=%d aux=%d\n", __func__, ctx,
 		default_pp_num, aux_pp_num);
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt));
 
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_video.c b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
index b0fc8fc0253..6924e6499ac 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_video.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
@@ -123,7 +123,7 @@ int mdss_mdp_video_addr_setup(struct mdss_data_type *mdata,
 
 	for (i = 0; i < count; i++) {
 		head[i].base = mdata->mdss_io.base + offsets[i];
-		pr_debug("adding Video Intf #%d offset=0x%x virt=%pK\n", i,
+		pr_debug("adding Video Intf #%d offset=0x%x virt=%p\n", i,
 				offsets[i], head[i].base);
 		head[i].ref_cnt = 0;
 		head[i].intf_num = i + MDSS_MDP_INTF0;
@@ -520,7 +520,7 @@ static int mdss_mdp_video_intfs_stop(struct mdss_mdp_ctl *ctl,
 		pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 		return -ENODEV;
 	}
-	pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num, ctx->intf_num,
+	pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num, ctx->intf_num,
 			ctx->base);
 
 	ret = mdss_mdp_video_ctx_stop(ctl, pinfo, ctx);
@@ -538,7 +538,7 @@ static int mdss_mdp_video_intfs_stop(struct mdss_mdp_ctl *ctl,
 			pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 			return -ENODEV;
 		}
-		pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num,
+		pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num,
 				sctx->intf_num, sctx->base);
 
 		ret = mdss_mdp_video_ctx_stop(ctl, pinfo, sctx);
@@ -1535,7 +1535,7 @@ static int mdss_mdp_video_intfs_setup(struct mdss_mdp_ctl *ctl,
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 	} else {
 		pr_err("Invalid intf number: %d\n", (inum + MDSS_MDP_INTF0));
@@ -1568,7 +1568,7 @@ static int mdss_mdp_video_intfs_setup(struct mdss_mdp_ctl *ctl,
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 
 		ctl->intf_ctx[SLAVE_CTX] = ctx;
diff --git a/drivers/video/msm/mdss/mdss_mdp_layer.c b/drivers/video/msm/mdss/mdss_mdp_layer.c
index 06156253316..2e8008d1058 100644
--- a/drivers/video/msm/mdss/mdss_mdp_layer.c
+++ b/drivers/video/msm/mdss/mdss_mdp_layer.c
@@ -446,7 +446,7 @@ static int __configure_pipe_params(struct msm_fb_data_type *mfd,
 	mixer = mdss_mdp_mixer_get(mdp5_data->ctl, mixer_mux);
 	pipe->src_fmt = mdss_mdp_get_format_params(layer->buffer.format);
 	if (!pipe->src_fmt || !mixer) {
-		pr_err("invalid layer format:%d or mixer:%pK\n",
+		pr_err("invalid layer format:%d or mixer:%p\n",
 				layer->buffer.format, pipe->mixer_left);
 		ret = -EINVAL;
 		goto end;
@@ -1354,7 +1354,7 @@ validate_exit:
 			}
 		} else {
 			pipe->file = file;
-			pr_debug("file pointer attached with pipe is %pK\n",
+			pr_debug("file pointer attached with pipe is %p\n",
 				file);
 		}
 	}
diff --git a/drivers/video/msm/mdss/mdss_mdp_overlay.c b/drivers/video/msm/mdss/mdss_mdp_overlay.c
index 14d11aa3206..495b28fa4f6 100644
--- a/drivers/video/msm/mdss/mdss_mdp_overlay.c
+++ b/drivers/video/msm/mdss/mdss_mdp_overlay.c
@@ -1080,7 +1080,7 @@ struct mdss_mdp_data *mdss_mdp_overlay_buf_alloc(struct msm_fb_data_type *mfd,
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_used);
 	list_add_tail(&buf->pipe_list, &pipe->buf_queue);
 
-	pr_debug("buffer alloc: %pK\n", buf);
+	pr_debug("buffer alloc: %p\n", buf);
 
 	return buf;
 }
@@ -1134,7 +1134,7 @@ void mdss_mdp_overlay_buf_free(struct msm_fb_data_type *mfd,
 	buf->last_freed = local_clock();
 	buf->state = MDP_BUF_STATE_UNUSED;
 
-	pr_debug("buffer freed: %pK\n", buf);
+	pr_debug("buffer freed: %p\n", buf);
 
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_pool);
 }
@@ -1474,7 +1474,7 @@ static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
 		if (buf) {
 			switch (buf->state) {
 			case MDP_BUF_STATE_READY:
-				pr_debug("pnum=%d buf=%pK first buffer ready\n",
+				pr_debug("pnum=%d buf=%p first buffer ready\n",
 						pipe->num, buf);
 				break;
 			case MDP_BUF_STATE_ACTIVE:
@@ -1494,7 +1494,7 @@ static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
 				}
 				break;
 			default:
-				pr_err("invalid state of buf %pK=%d\n",
+				pr_err("invalid state of buf %p=%d\n",
 						buf, buf->state);
 				BUG();
 				break;
@@ -2160,7 +2160,7 @@ static int __mdss_mdp_overlay_release_all(struct msm_fb_data_type *mfd,
 	u32 unset_ndx = 0;
 	int cnt = 0;
 
-	pr_debug("releasing all resources for fb%d file:%pK\n",
+	pr_debug("releasing all resources for fb%d file:%p\n",
 		mfd->index, file);
 
 	mutex_lock(&mdp5_data->ov_lock);
@@ -3440,21 +3440,12 @@ static int mdss_mdp_hw_cursor_pipe_update(struct msm_fb_data_type *mfd,
 		start_y = 0;
 	}
 
-	if ((img->width > mdata->max_cursor_size) ||
-		(img->height > mdata->max_cursor_size) ||
-		(img->depth != 32) || (start_x >= xres) ||
-		(start_y >= yres)) {
-		pr_err("Invalid cursor image coordinates\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
 	roi.w = min(xres - start_x, img->width - roi.x);
 	roi.h = min(yres - start_y, img->height - roi.y);
 
 	if ((roi.w > mdata->max_cursor_size) ||
-		(roi.h > mdata->max_cursor_size)) {
-		pr_err("Invalid cursor ROI size\n");
+		(roi.h > mdata->max_cursor_size) ||
+		(img->depth != 32) || (start_x >= xres) || (start_y >= yres)) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -3952,14 +3943,11 @@ static int mdss_fb_get_metadata(struct msm_fb_data_type *mfd,
 		break;
 	case metadata_op_get_ion_fd:
 		if (mfd->fb_ion_handle) {
-			get_dma_buf(mfd->fbmem_buf);
 			metadata->data.fbmem_ionfd =
 				dma_buf_fd(mfd->fbmem_buf, 0);
-			if (metadata->data.fbmem_ionfd < 0) {
-				dma_buf_put(mfd->fbmem_buf);
+			if (metadata->data.fbmem_ionfd < 0)
 				pr_err("fd allocation failed. fd = %d\n",
 						metadata->data.fbmem_ionfd);
-			}
 		}
 		break;
 	case metadata_op_crc:
diff --git a/drivers/video/msm/mdss/mdss_mdp_pipe.c b/drivers/video/msm/mdss/mdss_mdp_pipe.c
index f7fbb7fffa7..b14dd179953 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pipe.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pipe.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -2278,7 +2278,7 @@ int mdss_mdp_pipe_queue_data(struct mdss_mdp_pipe *pipe,
 	}
 
 	if (src_data == NULL) {
-		pr_debug("src_data=%pK pipe num=%dx\n",
+		pr_debug("src_data=%p pipe num=%dx\n",
 				src_data, pipe->num);
 		goto update_nobuf;
 	}
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp.c b/drivers/video/msm/mdss/mdss_mdp_pp.c
index 9e5df41725d..580d10b4a80 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp.c
@@ -1096,7 +1096,7 @@ static int pp_rgb_pipe_setup(struct mdss_mdp_pipe *pipe, u32 *op)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %pK\n", pipe);
+		pr_err("invalid param pipe %p\n", pipe);
 		return -EINVAL;
 	}
 	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN &&
@@ -1114,7 +1114,7 @@ static int pp_dma_pipe_setup(struct mdss_mdp_pipe *pipe, u32 *op)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %pK\n", pipe);
+		pr_err("invalid param pipe %p\n", pipe);
 		return -EINVAL;
 	}
 	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN &&
@@ -1435,7 +1435,7 @@ void mdss_mdp_pipe_pp_clear(struct mdss_mdp_pipe *pipe)
 	struct pp_hist_col_info *hist_info;
 
 	if (!pipe) {
-		pr_err("Invalid pipe context passed, %pK\n",
+		pr_err("Invalid pipe context passed, %p\n",
 			pipe);
 		return;
 	}
@@ -1582,7 +1582,7 @@ static int pp_mixer_setup(struct mdss_mdp_mixer *mixer)
 	struct mdss_data_type *mdata = mdss_mdp_get_mdata();
 
 	if (!mixer || !mixer->ctl || !mixer->ctl->mfd || !mdata) {
-		pr_err("invalid parameters, mixer %pK ctl %pK mfd %pK mdata %pK\n",
+		pr_err("invalid parameters, mixer %p ctl %p mfd %p mdata %p\n",
 			mixer, (mixer ? mixer->ctl : NULL),
 			(mixer ? (mixer->ctl ? mixer->ctl->mfd : NULL) : NULL),
 			mdata);
@@ -2200,7 +2200,7 @@ int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd)
 	struct mdp_pa_v2_cfg_data *pa_v2_cache_cfg = NULL;
 
 	if (!mfd) {
-		pr_err("invalid input: mfd = 0x%pK\n", mfd);
+		pr_err("invalid input: mfd = 0x%p\n", mfd);
 		return -EINVAL;
 	}
 
@@ -2290,7 +2290,7 @@ int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -2431,7 +2431,7 @@ static int mdss_mdp_pp_dt_parse(struct device *dev)
 			ret = 0;
 		}
 	} else {
-		pr_err("invalid dev %pK mdata %pK\n", dev, mdata);
+		pr_err("invalid dev %p mdata %p\n", dev, mdata);
 		ret = -EINVAL;
 	}
 bail_out:
@@ -2570,7 +2570,7 @@ int mdss_mdp_pp_overlay_init(struct msm_fb_data_type *mfd)
 	struct mdss_data_type *mdata = mdss_mdp_get_mdata();
 
 	if (!mfd || !mdata) {
-		pr_err("Invalid mfd %pK mdata %pK\n", mfd, mdata);
+		pr_err("Invalid mfd %p mdata %p\n", mfd, mdata);
 		return -EPERM;
 	}
 
@@ -2586,7 +2586,7 @@ int mdss_mdp_pp_default_overlay_config(struct msm_fb_data_type *mfd,
 	int ret = 0;
 
 	if (!mfd || !pdata) {
-		pr_err("Invalid parameters mfd %pK pdata %pK\n", mfd, pdata);
+		pr_err("Invalid parameters mfd %p pdata %p\n", mfd, pdata);
 		return -EINVAL;
 	}
 
@@ -2639,7 +2639,7 @@ static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -2655,7 +2655,7 @@ static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
 
 	if (!ad->bl_mfd || !ad->bl_mfd->panel_info ||
 		!ad->bl_att_lut) {
-		pr_err("Invalid ad info: bl_mfd = 0x%pK, ad->bl_mfd->panel_info = 0x%pK, bl_att_lut = 0x%pK\n",
+		pr_err("Invalid ad info: bl_mfd = 0x%p, ad->bl_mfd->panel_info = 0x%p, bl_att_lut = 0x%p\n",
 			ad->bl_mfd,
 			(!ad->bl_mfd) ? NULL : ad->bl_mfd->panel_info,
 			ad->bl_att_lut);
@@ -3147,7 +3147,7 @@ int mdss_mdp_pcc_config(struct msm_fb_data_type *mfd,
 		if (pp_ops[PCC].pp_get_config) {
 			addr = mdss_mdp_get_dspp_addr_off(disp_num);
 			if (IS_ERR_OR_NULL(addr)) {
-				pr_err("invalid dspp base_addr %pK\n",
+				pr_err("invalid dspp base_addr %p\n",
 					addr);
 				ret = -EINVAL;
 				goto pcc_clk_off;
@@ -3835,7 +3835,7 @@ int mdss_mdp_hist_lut_config(struct msm_fb_data_type *mfd,
 		mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON);
 		base_addr = mdss_mdp_get_dspp_addr_off(dspp_num);
 		if (IS_ERR_OR_NULL(base_addr)) {
-			pr_err("invalid base addr %pK\n",
+			pr_err("invalid base addr %p\n",
 				base_addr);
 			ret = -EINVAL;
 			goto hist_lut_clk_off;
@@ -4063,7 +4063,7 @@ int mdss_mdp_gamut_config(struct msm_fb_data_type *mfd,
 		if (pp_ops[GAMUT].pp_get_config) {
 			addr = mdss_mdp_get_dspp_addr_off(disp_num);
 			if (IS_ERR_OR_NULL(addr)) {
-				pr_err("invalid dspp base addr %pK\n",
+				pr_err("invalid dspp base addr %p\n",
 				       addr);
 				ret = -EINVAL;
 				goto gamut_clk_off;
@@ -4249,7 +4249,7 @@ static int pp_hist_enable(struct pp_hist_col_info *hist_info,
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_err("%s Hist collection has already been enabled %pK\n",
+		pr_err("%s Hist collection has already been enabled %p\n",
 			__func__, hist_info->base);
 		ret = -EBUSY;
 		goto exit;
@@ -4405,7 +4405,7 @@ static int pp_hist_disable(struct pp_hist_col_info *hist_info)
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en == false) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_debug("Histogram already disabled (%pK)\n", hist_info->base);
+		pr_debug("Histogram already disabled (%p)\n", hist_info->base);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -4508,7 +4508,7 @@ int mdss_mdp_hist_intr_req(struct mdss_intr *intr, u32 bits, bool en)
 	unsigned long flag;
 	int ret = 0;
 	if (!intr) {
-		pr_err("NULL addr passed, %pK\n", intr);
+		pr_err("NULL addr passed, %p\n", intr);
 		return -EINVAL;
 	}
 
@@ -5086,7 +5086,7 @@ static int mdss_mdp_get_ad(struct msm_fb_data_type *mfd,
 
 	*ret_ad = NULL;
 	if (!mfd) {
-		pr_err("invalid parameter mfd %pK\n", mfd);
+		pr_err("invalid parameter mfd %p\n", mfd);
 		return -EINVAL;
 	}
 	mdata = mfd_to_mdata(mfd);
@@ -5133,7 +5133,7 @@ static int pp_ad_invalidate_input(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -5168,7 +5168,7 @@ int mdss_mdp_ad_config(struct msm_fb_data_type *mfd,
 			mfd->index);
 		return ret;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -5285,7 +5285,7 @@ int mdss_mdp_ad_input(struct msm_fb_data_type *mfd,
 			mfd->index);
 		return ret;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -5638,7 +5638,7 @@ static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd)
 	struct mdss_ad_info *ad;
 
 	if (!mfd) {
-		pr_err("mfd = 0x%pK\n", mfd);
+		pr_err("mfd = 0x%p\n", mfd);
 		return -EINVAL;
 	}
 
@@ -5648,7 +5648,7 @@ static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -5672,13 +5672,13 @@ static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd)
 	u32 width;
 
 	if (!mfd) {
-		pr_err("mfd = 0x%pK\n", mfd);
+		pr_err("mfd = 0x%p\n", mfd);
 		return -EINVAL;
 	}
 
 	ctl = mfd_to_ctl(mfd);
 	if (!ctl) {
-		pr_err("ctl = 0x%pK\n", ctl);
+		pr_err("ctl = 0x%p\n", ctl);
 		return -EINVAL;
 	}
 	sctl = mdss_mdp_get_split_ctl(ctl);
@@ -5689,7 +5689,7 @@ static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
 			ret, ad);
 		return ret;
 	}
@@ -5873,7 +5873,7 @@ static void pp_ad_calc_worker(struct work_struct *work)
 	}
 	mdp5_data = mfd_to_mdp5_data(ad->mfd);
 	if (!mdp5_data) {
-		pr_err("mdp5_data = 0x%pK\n", mdp5_data);
+		pr_err("mdp5_data = 0x%p\n", mdp5_data);
 		mutex_unlock(&ad->lock);
 		return;
 	}
@@ -5881,7 +5881,7 @@ static void pp_ad_calc_worker(struct work_struct *work)
 	ctl = mfd_to_ctl(ad->mfd);
 	mdata = mfd_to_mdata(ad->mfd);
 	if (!ctl || !mdata || ad->calc_hw_num >= mdata->nad_cfgs) {
-		pr_err("ctl = 0x%pK, mdata = 0x%pK, ad->calc_hw_num = %d, mdata->nad_cfg = %d\n",
+		pr_err("ctl = 0x%p, mdata = 0x%p, ad->calc_hw_num = %d, mdata->nad_cfg = %d\n",
 			ctl, mdata, ad->calc_hw_num,
 			(!mdata ? 0 : mdata->nad_cfgs));
 		mutex_unlock(&ad->lock);
@@ -6327,6 +6327,9 @@ static int is_valid_calib_addr(void *addr, u32 operation)
 	int ret = 0;
 	char __iomem *ptr = addr;
 	char __iomem *mixer_base = mdss_res->mixer_intf->base;
+	char __iomem *rgb_base   = mdss_res->rgb_pipes->base;
+	char __iomem *dma_base   = mdss_res->dma_pipes->base;
+	char __iomem *vig_base   = mdss_res->vig_pipes->base;
 	char __iomem *ctl_base   = mdss_res->ctl_off->base;
 	char __iomem *dspp_base  = mdss_res->mixer_intf->dspp_base;
 
@@ -6358,20 +6361,17 @@ static int is_valid_calib_addr(void *addr, u32 operation)
 			if (ret)
 				goto valid_addr;
 		}
-		if (mdss_res->vig_pipes &&
-		    ptr >= mdss_res->vig_pipes->base) {
+		if (ptr >= vig_base) {
 			ret = is_valid_calib_vig_addr(ptr);
 			if (ret)
 				goto valid_addr;
 		}
-		if (mdss_res->rgb_pipes &&
-		    ptr >= mdss_res->rgb_pipes->base) {
+		if (ptr >= rgb_base) {
 			ret = is_valid_calib_rgb_addr(ptr);
 			if (ret)
 				goto valid_addr;
 		}
-		if (mdss_res->dma_pipes &&
-		    mdss_res->dma_pipes->base) {
+		if (ptr >= dma_base) {
 			ret = is_valid_calib_dma_addr(ptr);
 			if (ret)
 				goto valid_addr;
@@ -6492,7 +6492,7 @@ static int sspp_cache_location(u32 pipe_type, enum pp_config_block *block)
 	int ret = 0;
 
 	if (!block) {
-		pr_err("invalid params %pK\n", block);
+		pr_err("invalid params %p\n", block);
 		return -EINVAL;
 	}
 	switch (pipe_type) {
@@ -6521,7 +6521,7 @@ int mdss_mdp_pp_sspp_config(struct mdss_mdp_pipe *pipe)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid params, pipe %pK\n", pipe);
+		pr_err("invalid params, pipe %p\n", pipe);
 		return -EINVAL;
 	}
 
@@ -6643,7 +6643,7 @@ static int pp_update_pcc_pipe_setup(struct mdss_mdp_pipe *pipe, u32 location)
 	char __iomem *pipe_base = NULL;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %pK\n", pipe);
+		pr_err("invalid param pipe %p\n", pipe);
 		return -EINVAL;
 	}
 
@@ -6695,7 +6695,7 @@ int mdss_mdp_pp_get_version(struct mdp_pp_feature_version *version)
 	u32 ver_info = mdp_pp_legacy;
 
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		ret = -EINVAL;
 		goto exit_version;
 	}
@@ -6776,7 +6776,7 @@ int mdss_mdp_copy_layer_pp_info(struct mdp_input_layer *layer)
 	uint32_t ops;
 
 	if (!layer) {
-		pr_err("invalid layer pointer passed %pK\n", layer);
+		pr_err("invalid layer pointer passed %p\n", layer);
 		return -EFAULT;
 	}
 
@@ -6788,7 +6788,7 @@ int mdss_mdp_copy_layer_pp_info(struct mdp_input_layer *layer)
 	ret = copy_from_user(pp_info, layer->pp_info,
 			sizeof(struct mdp_overlay_pp_params));
 	if (ret) {
-		pr_err("layer list copy from user failed, pp_info = %pK\n",
+		pr_err("layer list copy from user failed, pp_info = %p\n",
 			layer->pp_info);
 		ret = -EFAULT;
 		goto exit_pp_info;
@@ -6921,7 +6921,7 @@ static int pp_mfd_ad_release_all(struct msm_fb_data_type *mfd)
 	int ret = 0;
 
 	if (!mdata || !mfd) {
-		pr_err("invalid params mdata %pK mfd %pK\n", mdata, mfd);
+		pr_err("invalid params mdata %p mfd %p\n", mdata, mfd);
 		return -EINVAL;
 	}
 	if (!mdata->ad_calc_wq)
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c b/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
index 5fe7e4820c6..7769a8fbf64 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
@@ -103,7 +103,7 @@ static int pp_hist_lut_cache_params_v1_7(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -113,7 +113,7 @@ static int pp_hist_lut_cache_params_v1_7(struct mdp_hist_lut_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -165,7 +165,7 @@ static int pp_hist_lut_cache_params_pipe_v1_7(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !pipe) {
-		pr_err("Invalid param config %pK pipe %pK\n",
+		pr_err("Invalid param config %p pipe %p\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -236,7 +236,7 @@ int pp_hist_lut_cache_params(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !res_cache) {
-		pr_err("invalid param config %pK res_cache %pK\n",
+		pr_err("invalid param config %p res_cache %p\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -245,7 +245,7 @@ int pp_hist_lut_cache_params(struct mdp_hist_lut_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
+		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -286,7 +286,7 @@ int pp_dither_cache_params_v1_7(struct mdp_dither_cfg_data *config,
 	struct mdp_dither_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -296,7 +296,7 @@ int pp_dither_cache_params_v1_7(struct mdp_dither_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -358,7 +358,7 @@ int pp_dither_cache_params(struct mdp_dither_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %pi pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -387,7 +387,7 @@ static int pp_gamut_cache_params_v1_7(struct mdp_gamut_cfg_data *config,
 	int ret = 0, i = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -398,7 +398,7 @@ static int pp_gamut_cache_params_v1_7(struct mdp_gamut_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 	res_cache = mdss_pp_res->pp_data_res;
@@ -555,7 +555,7 @@ int pp_gamut_cache_params(struct mdp_gamut_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -578,7 +578,7 @@ static int pp_pcc_cache_params_pipe_v1_7(struct mdp_pcc_cfg_data *config,
 	struct mdp_pcc_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 
 	if (!pipe || !config) {
-		pr_err("invalid params pipe %pK config %pK\n", pipe, config);
+		pr_err("invalid params pipe %p config %p\n", pipe, config);
 		return -EINVAL;
 	}
 
@@ -636,7 +636,7 @@ static int pp_pcc_cache_params_v1_7(struct mdp_pcc_cfg_data *config,
 	struct mdp_pcc_data_v1_7 *v17_cache_data, v17_usr_config;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -647,7 +647,7 @@ static int pp_pcc_cache_params_v1_7(struct mdp_pcc_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -687,7 +687,7 @@ int pp_pcc_cache_params(struct mdp_pcc_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -696,7 +696,7 @@ int pp_pcc_cache_params(struct mdp_pcc_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
+		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -735,7 +735,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 	struct mdp_igc_lut_data_v1_7 *v17_cache_data, v17_usr_config;
 	u32 disp_num;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -745,7 +745,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 	res_cache = mdss_pp_res->pp_data_res;
@@ -781,7 +781,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 		}
 		if (copy_from_kernel && (!v17_usr_config.c0_c1_data ||
 		    !v17_usr_config.c2_data)) {
-			pr_err("copy from kernel invalid params c0_c1_data %pK c2_data %pK\n",
+			pr_err("copy from kernel invalid params c0_c1_data %p c2_data %p\n",
 				v17_usr_config.c0_c1_data,
 				v17_usr_config.c2_data);
 			ret = -EINVAL;
@@ -837,7 +837,7 @@ static int pp_igc_lut_cache_params_pipe_v1_7(struct mdp_igc_lut_data *config,
 	struct mdp_igc_lut_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 	int ret = 0, fix_up = 0, i = 0;
 	if (!config || !pipe) {
-		pr_err("invalid param config %pK pipe %pK\n",
+		pr_err("invalid param config %p pipe %p\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -865,7 +865,7 @@ static int pp_igc_lut_cache_params_pipe_v1_7(struct mdp_igc_lut_data *config,
 		if (!v17_usr_config.c0_c1_data ||
 		    !v17_usr_config.c2_data ||
 		    v17_usr_config.len != IGC_LUT_ENTRIES) {
-			pr_err("invalid c0_c1data %pK c2_data %pK tbl len %d\n",
+			pr_err("invalid c0_c1data %p c2_data %p tbl len %d\n",
 					v17_usr_config.c0_c1_data,
 					v17_usr_config.c2_data,
 					v17_usr_config.len);
@@ -959,7 +959,7 @@ int pp_igc_lut_cache_params(struct mdp_igc_lut_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -968,7 +968,7 @@ int pp_igc_lut_cache_params(struct mdp_igc_lut_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
+		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		ret = -EINVAL;
@@ -1103,7 +1103,7 @@ int pp_pgc_lut_cache_params(struct mdp_pgc_lut_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -1128,7 +1128,7 @@ static int pp_pa_cache_params_v1_7(struct mdp_pa_v2_cfg_data *config,
 	int disp_num, ret = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("Invalid param config %pK pp_res %pK\n",
+		pr_err("Invalid param config %p pp_res %p\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -1140,7 +1140,7 @@ static int pp_pa_cache_params_v1_7(struct mdp_pa_v2_cfg_data *config,
 	}
 
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("Invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
+		pr_err("Invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -1228,7 +1228,7 @@ static int pp_pa_cache_params_pipe_v1_7(struct mdp_pa_v2_cfg_data *config,
 	int ret = 0;
 
 	if (!config || !pipe) {
-		pr_err("Invalid param config %pK pipe %pK\n",
+		pr_err("Invalid param config %p pipe %p\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -1284,7 +1284,7 @@ int pp_pa_cache_params(struct mdp_pa_v2_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %pK pp_res %pK\n",
+		pr_err("invalid param config %p pp_res %p\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -1293,7 +1293,7 @@ int pp_pa_cache_params(struct mdp_pa_v2_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
+		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -1344,7 +1344,7 @@ int pp_copy_layer_igc_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->igc_cfg.cfg_payload,
 				sizeof(struct mdp_igc_lut_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, IGC cfg payload = %pK\n",
+			pr_err("layer list copy from user failed, IGC cfg payload = %p\n",
 				pp_info->igc_cfg.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1382,7 +1382,7 @@ int pp_copy_layer_hist_lut_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->hist_lut_cfg.cfg_payload,
 				sizeof(struct mdp_hist_lut_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, Hist LUT cfg payload = %pK\n",
+			pr_err("layer list copy from user failed, Hist LUT cfg payload = %p\n",
 				pp_info->hist_lut_cfg.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1420,7 +1420,7 @@ int pp_copy_layer_pa_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->pa_v2_cfg_data.cfg_payload,
 				sizeof(struct mdp_pa_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, PA cfg payload = %pK\n",
+			pr_err("layer list copy from user failed, PA cfg payload = %p\n",
 				pp_info->pa_v2_cfg_data.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1458,7 +1458,7 @@ int pp_copy_layer_pcc_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->pcc_cfg_data.cfg_payload,
 				sizeof(struct mdp_pcc_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, PCC cfg payload = %pK\n",
+			pr_err("layer list copy from user failed, PCC cfg payload = %p\n",
 				pp_info->pcc_cfg_data.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c b/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
index bc19b5b82ee..fe88fe67617 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
@@ -245,7 +245,7 @@ static void pp_gamut_clock_gating_en(char __iomem *base_addr);
 void *pp_get_driver_ops(struct mdp_pp_driver_ops *ops)
 {
 	if (!ops) {
-		pr_err("PP driver ops invalid %pK\n", ops);
+		pr_err("PP driver ops invalid %p\n", ops);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -307,7 +307,7 @@ static void pp_opmode_config(int location, struct pp_sts_type *pp_sts,
 		u32 *opmode, int side)
 {
 	if (!pp_sts || !opmode) {
-		pr_err("Invalid pp_sts %pK or opmode %pK\n", pp_sts, opmode);
+		pr_err("Invalid pp_sts %p or opmode %p\n", pp_sts, opmode);
 		return;
 	}
 	switch (location) {
@@ -361,7 +361,7 @@ static int pp_hist_lut_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_hist_lut_data *lut_cfg_data = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -373,7 +373,7 @@ static int pp_hist_lut_get_config(char __iomem *base_addr, void *cfg_data,
 	}
 	if (lut_cfg_data->version != mdp_hist_lut_v1_7 ||
 		!lut_cfg_data->cfg_payload) {
-		pr_err("invalid hist_lut version %d payload %pK\n",
+		pr_err("invalid hist_lut version %d payload %p\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload);
 		return -EINVAL;
 	}
@@ -438,7 +438,7 @@ static int pp_hist_lut_set_config(char __iomem *base_addr,
 	char __iomem *hist_addr = NULL, *swap_addr = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -464,12 +464,12 @@ static int pp_hist_lut_set_config(char __iomem *base_addr,
 	}
 	lut_data = lut_cfg_data->cfg_payload;
 	if (!lut_data) {
-		pr_err("invalid hist_lut cfg_payload %pK\n", lut_data);
+		pr_err("invalid hist_lut cfg_payload %p\n", lut_data);
 		return -EINVAL;
 	}
 
 	if (lut_data->len != ENHIST_LUT_ENTRIES || !lut_data->data) {
-		pr_err("invalid hist_lut len %d data %pK\n",
+		pr_err("invalid hist_lut len %d data %p\n",
 		       lut_data->len, lut_data->data);
 		return -EINVAL;
 	}
@@ -533,7 +533,7 @@ static int pp_dither_set_config(char __iomem *base_addr,
 	uint32_t *pdata = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -560,7 +560,7 @@ static int pp_dither_set_config(char __iomem *base_addr,
 
 	dither_data = dither_cfg_data->cfg_payload;
 	if (!dither_data) {
-		pr_err("invalid payload for dither %pK\n", dither_data);
+		pr_err("invalid payload for dither %p\n", dither_data);
 		return -EINVAL;
 	}
 
@@ -608,7 +608,7 @@ static int pp_hist_get_config(char __iomem *base_addr, void *cfg_data,
 	struct pp_hist_col_info *hist_info = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -646,7 +646,7 @@ static int pp_get_hist_offset(u32 block, u32 *ctl_off)
 	int ret = 0;
 
 	if (!ctl_off) {
-		pr_err("invalid params ctl_off %pK\n", ctl_off);
+		pr_err("invalid params ctl_off %p\n", ctl_off);
 		return -EINVAL;
 	}
 	switch (block) {
@@ -667,7 +667,7 @@ static int pp_get_hist_offset(u32 block, u32 *ctl_off)
 static int pp_get_hist_isr(u32 *isr_mask)
 {
 	if (!isr_mask) {
-		pr_err("invalid params isr_mask %pK\n", isr_mask);
+		pr_err("invalid params isr_mask %p\n", isr_mask);
 		return -EINVAL;
 	}
 
@@ -693,7 +693,7 @@ static int pp_gamut_get_config(char __iomem *base_addr, void *cfg_data,
 	u32 clk_gate_disable = 0;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -831,7 +831,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	struct mdp_gamut_data_v1_7 *gamut_data = NULL;
 	char __iomem *base_addr_scale = base_addr;
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -853,7 +853,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	gamut_data = (struct mdp_gamut_data_v1_7 *)
 		      gamut_cfg_data->cfg_payload;
 	if (!gamut_data) {
-		pr_err("invalid payload for gamut %pK\n", gamut_data);
+		pr_err("invalid payload for gamut %p\n", gamut_data);
 		return -EINVAL;
 	}
 
@@ -872,7 +872,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	for (i = 0; i < MDP_GAMUT_TABLE_NUM_V1_7; i++) {
 		if (!gamut_data->c0_data[i] || !gamut_data->c1_c2_data[i]
 		    || (gamut_data->tbl_size[i] != tbl_sz)) {
-			pr_err("invalid param for c0 %pK c1c2 %pK table %d size %d expected sz %d\n",
+			pr_err("invalid param for c0 %p c1c2 %p table %d size %d expected sz %d\n",
 			       gamut_data->c0_data[i],
 			       gamut_data->c1_c2_data[i], i,
 			       gamut_data->tbl_size[i], tbl_sz);
@@ -883,7 +883,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 		    (!gamut_data->scale_off_data[i] ||
 		    (gamut_data->tbl_scale_off_sz[i] !=
 		    MDP_GAMUT_SCALE_OFF_SZ))) {
-			pr_err("invalid param for scale table %pK for c%d size %d expected size%d\n",
+			pr_err("invalid param for scale table %p for c%d size %d expected size%d\n",
 				gamut_data->scale_off_data[i], i,
 				gamut_data->tbl_scale_off_sz[i],
 				MDP_GAMUT_SCALE_OFF_SZ);
@@ -948,7 +948,7 @@ static int pp_pcc_set_config(char __iomem *base_addr,
 	u32 opmode = 0;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts %p\n",
 			base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -963,7 +963,7 @@ static int pp_pcc_set_config(char __iomem *base_addr,
 	}
 	pcc_data = pcc_cfg_data->cfg_payload;
 	if (!pcc_data) {
-		pr_err("invalid payload for pcc %pK\n", pcc_data);
+		pr_err("invalid payload for pcc %p\n", pcc_data);
 		return -EINVAL;
 	}
 
@@ -1033,7 +1033,7 @@ static int pp_pcc_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_pcc_data_v1_7 pcc_data;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -1230,7 +1230,7 @@ static void pp_pa_set_six_zone(char __iomem *base_addr,
 
 	if (!pa_data->six_zone_len || !pa_data->six_zone_curve_p0 ||
 	    !pa_data->six_zone_curve_p1) {
-		pr_err("Invalid six zone data: len %d curve_p0 %pK curve_p1 %pK\n",
+		pr_err("Invalid six zone data: len %d curve_p0 %p curve_p1 %p\n",
 		       pa_data->six_zone_len,
 		       pa_data->six_zone_curve_p0,
 		       pa_data->six_zone_curve_p1);
@@ -1348,7 +1348,7 @@ static int pp_pa_set_config(char __iomem *base_addr,
 	int ret = 0;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1373,7 +1373,7 @@ static int pp_pa_set_config(char __iomem *base_addr,
 
 	pa_data = pa_cfg_data->cfg_payload;
 	if (!pa_data) {
-		pr_err("invalid payload for pa %pK\n", pa_data);
+		pr_err("invalid payload for pa %p\n", pa_data);
 		return -EINVAL;
 	}
 
@@ -1622,7 +1622,7 @@ static int pp_pa_get_config(char __iomem *base_addr, void *cfg_data,
 	char __iomem *pa_hold_addr = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p\n",
 		      base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -1755,7 +1755,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	u32 data;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1763,7 +1763,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	lut_cfg_data = (struct mdp_igc_lut_data *) cfg_data;
 	if (lut_cfg_data->version != mdp_igc_v1_7 ||
 	    !lut_cfg_data->cfg_payload) {
-		pr_err("invalid igc version %d payload %pK\n",
+		pr_err("invalid igc version %d payload %p\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload);
 		return -EINVAL;
 	}
@@ -1782,7 +1782,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	lut_data = lut_cfg_data->cfg_payload;
 	if (lut_data->len != IGC_LUT_ENTRIES || !lut_data->c0_c1_data ||
 	    !lut_data->c2_data) {
-		pr_err("invalid lut len %d c0_c1_data %pK  c2_data %pK\n",
+		pr_err("invalid lut len %d c0_c1_data %p  c2_data %p\n",
 		       lut_data->len, lut_data->c0_c1_data, lut_data->c2_data);
 		return -EINVAL;
 	}
@@ -1849,7 +1849,7 @@ static int pp_igc_get_config(char __iomem *base_addr, void *cfg_data,
 	u32 data = 0, sz = 0;
 
 	if (!base_addr || !cfg_data || block_type != DSPP) {
-		pr_err("invalid params base_addr %pK cfg_data %pK block_type %d\n",
+		pr_err("invalid params base_addr %p cfg_data %p block_type %d\n",
 		      base_addr, cfg_data, block_type);
 		return -EINVAL;
 	}
@@ -1861,7 +1861,7 @@ static int pp_igc_get_config(char __iomem *base_addr, void *cfg_data,
 	if (lut_cfg_data->version != mdp_igc_v1_7 ||
 	    !lut_cfg_data->cfg_payload ||
 	    lut_cfg_data->block > IGC_MASK_MAX) {
-		pr_err("invalid igc version %d payload %pK block %d\n",
+		pr_err("invalid igc version %d payload %p block %d\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload,
 		       lut_cfg_data->block);
 		ret = -EINVAL;
@@ -1926,7 +1926,7 @@ static int pp_pgc_set_config(char __iomem *base_addr,
 	struct mdp_pgc_lut_data_v1_7  *pgc_data_v17 = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
+		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1952,13 +1952,13 @@ static int pp_pgc_set_config(char __iomem *base_addr,
 
 	pgc_data_v17 = (struct mdp_pgc_lut_data_v1_7 *) pgc_data->cfg_payload;
 	if (!pgc_data_v17) {
-		pr_err("invalid payload for GC %pK\n", pgc_data_v17);
+		pr_err("invalid payload for GC %p\n", pgc_data_v17);
 		return -EINVAL;
 	}
 
 	if (pgc_data_v17->len != PGC_LUT_ENTRIES || !pgc_data_v17->c0_data ||
 	    !pgc_data_v17->c1_data || !pgc_data_v17->c2_data) {
-		pr_err("Invalid params entries %d c0_data %pK c1_data %pK c2_data %pK\n",
+		pr_err("Invalid params entries %d c0_data %p c1_data %p c2_data %p\n",
 			pgc_data_v17->len, pgc_data_v17->c0_data,
 			pgc_data_v17->c1_data, pgc_data_v17->c2_data);
 		return -EINVAL;
@@ -2011,7 +2011,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_pgc_lut_data *pgc_data = NULL;
 	struct mdp_pgc_lut_data_v1_7  *pgc_data_v17 = NULL;
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %pK cfg_data %pK block_type %d\n",
+		pr_err("invalid params base_addr %p cfg_data %p block_type %d\n",
 		      base_addr, cfg_data, block_type);
 		return -EINVAL;
 	}
@@ -2019,7 +2019,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 	pgc_data_v17 = (struct mdp_pgc_lut_data_v1_7 *)
 			pgc_data->cfg_payload;
 	if (pgc_data->version != mdp_pgc_v1_7 || !pgc_data_v17) {
-		pr_err("invalid pgc version %d payload %pK\n",
+		pr_err("invalid pgc version %d payload %p\n",
 			pgc_data->version, pgc_data_v17);
 		return -EINVAL;
 	}
@@ -2081,7 +2081,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 static int pp_pcc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pcc_v1_7;
@@ -2091,7 +2091,7 @@ static int pp_pcc_get_version(u32 *version)
 static int pp_igc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_igc_v1_7;
@@ -2101,7 +2101,7 @@ static int pp_igc_get_version(u32 *version)
 static int pp_pgc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pgc_v1_7;
@@ -2111,7 +2111,7 @@ static int pp_pgc_get_version(u32 *version)
 static int pp_pa_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pa_v1_7;
@@ -2121,7 +2121,7 @@ static int pp_pa_get_version(u32 *version)
 static int pp_gamut_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_gamut_v1_7;
@@ -2131,7 +2131,7 @@ static int pp_gamut_get_version(u32 *version)
 static int pp_dither_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_dither_v1_7;
@@ -2141,7 +2141,7 @@ static int pp_dither_get_version(u32 *version)
 static int pp_hist_lut_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %pK\n", version);
+		pr_err("invalid param version %p\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_hist_lut_v1_7;
diff --git a/drivers/video/msm/mdss/mdss_mdp_rotator.c b/drivers/video/msm/mdss/mdss_mdp_rotator.c
index e5307da124f..ac957a09c95 100644
--- a/drivers/video/msm/mdss/mdss_mdp_rotator.c
+++ b/drivers/video/msm/mdss/mdss_mdp_rotator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -190,11 +190,11 @@ static struct mdss_mdp_rot_pipe *mdss_mdp_rot_mgr_acquire_pipe(
 			(free_rot_pipe->previous_session != rot);
 
 		rot_pipe = free_rot_pipe;
-		pr_debug("find a free pipe %pK\n", rot_pipe->pipe);
+		pr_debug("find a free pipe %p\n", rot_pipe->pipe);
 	} else {
 		rot_pipe = busy_rot_pipe;
 		if (rot_pipe)
-			pr_debug("find a busy pipe %pK\n", rot_pipe->pipe);
+			pr_debug("find a busy pipe %p\n", rot_pipe->pipe);
 	}
 
 	if (rot_pipe)
diff --git a/drivers/video/msm/mdss/mdss_mdp_util.c b/drivers/video/msm/mdss/mdss_mdp_util.c
index af4920cdd54..fba7c860023 100644
--- a/drivers/video/msm/mdss/mdss_mdp_util.c
+++ b/drivers/video/msm/mdss/mdss_mdp_util.c
@@ -1052,7 +1052,7 @@ static int mdss_mdp_put_img(struct mdss_mdp_img_data *data, bool rotator,
 		pr_debug("pmem buf=0x%pa\n", &data->addr);
 		memset(&data->srcp_f, 0, sizeof(struct fd));
 	} else if (!IS_ERR_OR_NULL(data->srcp_dma_buf)) {
-		pr_debug("ion hdl=%pK buf=0x%pa\n", data->srcp_dma_buf,
+		pr_debug("ion hdl=%p buf=0x%pa\n", data->srcp_dma_buf,
 							&data->addr);
 		if (!iclient) {
 			pr_err("invalid ion client\n");
@@ -1211,9 +1211,8 @@ static int mdss_mdp_get_img(struct msmfb_data *img,
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%lx\n",
-			 img->memory_id, data->srcp_dma_buf,
-			 &data->addr, data->len);
+		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%lx\n", img->memory_id,
+			 data->srcp_dma_buf, &data->addr, data->len);
 	} else {
 		mdss_mdp_put_img(data, rotator, dir);
 		return ret ? : -EOVERFLOW;
@@ -1268,7 +1267,7 @@ static int mdss_mdp_map_buffer(struct mdss_mdp_img_data *data, bool rotator,
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("ihdl=%pK buf=0x%pa len=0x%lx\n",
+		pr_debug("ihdl=%p buf=0x%pa len=0x%lx\n",
 			 data->srcp_dma_buf, &data->addr, data->len);
 	} else {
 		mdss_mdp_put_img(data, rotator, dir);
diff --git a/drivers/video/msm/mdss/mdss_mdp_wb.c b/drivers/video/msm/mdss/mdss_mdp_wb.c
index 993b8d69bb0..c9b69452d4a 100644
--- a/drivers/video/msm/mdss/mdss_mdp_wb.c
+++ b/drivers/video/msm/mdss/mdss_mdp_wb.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -95,7 +95,7 @@ struct mdss_mdp_data *mdss_mdp_wb_debug_buffer(struct msm_fb_data_type *mfd)
 		ihdl = ion_alloc(iclient, img_size, SZ_4K,
 				 ION_HEAP(ION_SF_HEAP_ID), 0);
 		if (IS_ERR_OR_NULL(ihdl)) {
-			pr_err("unable to alloc fbmem from ion (%pK)\n", ihdl);
+			pr_err("unable to alloc fbmem from ion (%p)\n", ihdl);
 			return NULL;
 		}
 
@@ -122,7 +122,7 @@ struct mdss_mdp_data *mdss_mdp_wb_debug_buffer(struct msm_fb_data_type *mfd)
 			img->len = img_size;
 		}
 
-		pr_debug("ihdl=%pK virt=%pK phys=0x%pa iova=0x%pa size=%u\n",
+		pr_debug("ihdl=%p virt=%p phys=0x%pa iova=0x%pa size=%u\n",
 			 ihdl, videomemory, &mdss_wb_mem, &img->addr, img_size);
 	}
 	return &mdss_wb_buffer;
@@ -437,7 +437,7 @@ static struct mdss_mdp_wb_data *get_user_node(struct msm_fb_data_type *mfd,
 		list_for_each_entry(node, &wb->register_queue, registered_entry)
 			if ((node->buf_data.p[0].srcp_ihdl == ihdl) &&
 				    (node->buf_info.offset == data->offset)) {
-				pr_debug("found fd=%d hdl=%pK off=%x addr=%pa\n",
+				pr_debug("found fd=%d hdl=%p off=%x addr=%pa\n",
 						data->memory_id, ihdl,
 						data->offset,
 						&node->buf_data.p[0].addr);
@@ -513,7 +513,7 @@ static void mdss_mdp_wb_free_node(struct mdss_mdp_wb_data *node)
 	if (node->user_alloc) {
 		buf = &node->buf_data.p[0];
 
-		pr_debug("free user mem_id=%d ihdl=%pK, offset=%u addr=0x%pa\n",
+		pr_debug("free user mem_id=%d ihdl=%p, offset=%u addr=0x%pa\n",
 				node->buf_info.memory_id,
 				buf->srcp_ihdl,
 				node->buf_info.offset,
diff --git a/drivers/video/msm/mdss/mdss_panel.c b/drivers/video/msm/mdss/mdss_panel.c
index 598270e2189..16b68d2a39e 100644
--- a/drivers/video/msm/mdss/mdss_panel.c
+++ b/drivers/video/msm/mdss/mdss_panel.c
@@ -451,12 +451,10 @@ int mdss_panel_debugfs_setup(struct mdss_panel_info *panel_info, struct dentry
 		return -ENOMEM;
 	}
 
-	debugfs_info->parent = parent;
 	debugfs_info->root = debugfs_create_dir(intf_str, parent);
 	if (IS_ERR_OR_NULL(debugfs_info->root)) {
 		pr_err("Debugfs create dir failed with error: %ld\n",
 					PTR_ERR(debugfs_info->root));
-		kfree(debugfs_info);
 		return -ENODEV;
 	}
 
@@ -501,7 +499,6 @@ int mdss_panel_debugfs_init(struct mdss_panel_info *panel_info,
 				intf_str);
 		if (rc) {
 			pr_err("error in initilizing panel debugfs\n");
-			mdss_panel_debugfs_cleanup(&pdata->panel_info);
 			return rc;
 		}
 		pdata = pdata->next;
@@ -515,16 +512,13 @@ void mdss_panel_debugfs_cleanup(struct mdss_panel_info *panel_info)
 {
 	struct mdss_panel_data *pdata;
 	struct mdss_panel_debugfs_info *debugfs_info;
-	struct dentry *parent = NULL;
 	pdata = container_of(panel_info, struct mdss_panel_data, panel_info);
 	do {
 		debugfs_info = pdata->panel_info.debugfs_info;
-		if (debugfs_info && !parent)
-			parent = debugfs_info->parent;
-		kfree(debugfs_info);
+		if (debugfs_info && debugfs_info->root)
+			debugfs_remove_recursive(debugfs_info->root);
 		pdata = pdata->next;
 	} while (pdata);
-	debugfs_remove_recursive(parent);
 	pr_debug("Cleaned up mdss_panel_debugfs_info\n");
 }
 
diff --git a/drivers/video/msm/mdss/mdss_panel.h b/drivers/video/msm/mdss/mdss_panel.h
index 8f165f7e215..617771c3055 100644
--- a/drivers/video/msm/mdss/mdss_panel.h
+++ b/drivers/video/msm/mdss/mdss_panel.h
@@ -376,7 +376,6 @@ struct mipi_panel_info {
 	char traffic_mode;
 	char frame_rate;
 	/* command mode */
-	char frame_rate_idle;
 	char interleave_max;
 	char insert_dcs_cmd;
 	char wr_mem_continue;
@@ -600,7 +599,6 @@ struct mdss_panel_info {
 	u32 partial_update_roi_merge;
 	struct ion_handle *splash_ihdl;
 	int panel_power_state;
-	int blank_state;
 	int compression_mode;
 
 	uint32_t panel_dead;
@@ -640,7 +638,6 @@ struct mdss_panel_info {
 	void *dba_data;
 	void *cec_data;
 
-	u32 signature;
 	char panel_name[MDSS_MAX_PANEL_LEN];
 	struct mdss_mdp_pp_tear_check te;
 
@@ -668,7 +665,6 @@ struct mdss_panel_info {
 
 	/* debugfs structure for the panel */
 	struct mdss_panel_debugfs_info *debugfs_info;
-	u32 bl_pre;
 };
 
 struct mdss_panel_timing {
@@ -708,8 +704,7 @@ struct mdss_panel_data {
 	struct mdss_panel_info panel_info;
 	void (*set_backlight) (struct mdss_panel_data *pdata, u32 bl_level);
 	unsigned char *mmss_cc_base;
-	void (*set_idle)(struct mdss_panel_data *pdata, int enable); /* for lp mode */
-	int (*get_idle)(struct mdss_panel_data *pdata);
+
 	/**
 	 * event_handler() - callback handler for MDP core events
 	 * @pdata:	Pointer refering to the panel struct associated to this
@@ -735,7 +730,6 @@ struct mdss_panel_data {
 
 struct mdss_panel_debugfs_info {
 	struct dentry *root;
-	struct dentry *parent;
 	struct mdss_panel_info panel_info;
 	u32 override_flag;
 	struct mdss_panel_debugfs_info *next;
@@ -749,10 +743,6 @@ static inline u32 mdss_panel_get_framerate(struct mdss_panel_info *panel_info)
 {
 	u32 frame_rate, pixel_total;
 	u64 rate;
-	struct mdss_panel_data *panel_data =
-			container_of(panel_info, typeof(*panel_data), panel_info);
-	int idle = 0;
-
 
 	if (panel_info == NULL)
 		return DEFAULT_FRAME_RATE;
@@ -761,12 +751,6 @@ static inline u32 mdss_panel_get_framerate(struct mdss_panel_info *panel_info)
 	case MIPI_VIDEO_PANEL:
 	case MIPI_CMD_PANEL:
 		frame_rate = panel_info->mipi.frame_rate;
-		 if (panel_data->get_idle)
-			 idle = panel_data->get_idle(panel_data);
-		if (idle)
-			frame_rate = panel_info->mipi.frame_rate_idle;
-		else
-			frame_rate = panel_info->mipi.frame_rate;
 		break;
 	case EDP_PANEL:
 		frame_rate = panel_info->edp.frame_rate;
diff --git a/drivers/video/msm/mdss/mdss_rotator.c b/drivers/video/msm/mdss/mdss_rotator.c
index 8db624fd848..9ed6bdb548e 100644
--- a/drivers/video/msm/mdss/mdss_rotator.c
+++ b/drivers/video/msm/mdss/mdss_rotator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -2055,12 +2055,10 @@ static int mdss_rotator_config_session(struct mdss_rot_mgr *mgr,
 		return ret;
 	}
 
-	mutex_lock(&mgr->lock);
 	perf = mdss_rotator_find_session(private, config.session_id);
 	if (!perf) {
 		pr_err("No session with id=%u could be found\n",
 			config.session_id);
-		mutex_unlock(&mgr->lock);
 		return -EINVAL;
 	}
 
@@ -2083,7 +2081,6 @@ static int mdss_rotator_config_session(struct mdss_rot_mgr *mgr,
 		config.output.format);
 done:
 	ATRACE_END(__func__);
-	mutex_unlock(&mgr->lock);
 	return ret;
 }
 
@@ -2660,8 +2657,8 @@ static int mdss_rotator_get_dt_vreg_data(struct device *dev,
 			mp->vreg_config[i].vreg_name,
 			mp->vreg_config[i].min_voltage,
 			mp->vreg_config[i].max_voltage,
-			mp->vreg_config[i].load[DSS_REG_MODE_ENABLE],
-			mp->vreg_config[i].load[DSS_REG_MODE_DISABLE]);
+			mp->vreg_config[i].enable_load,
+			mp->vreg_config[i].disable_load);
 	}
 	return rc;
 
diff --git a/drivers/video/msm/mdss/mdss_util.c b/drivers/video/msm/mdss/mdss_util.c
index 2f9dd4465ba..3a9ff9b6adb 100644
--- a/drivers/video/msm/mdss/mdss_util.c
+++ b/drivers/video/msm/mdss/mdss_util.c
@@ -33,7 +33,7 @@ int mdss_register_irq(struct mdss_hw *hw)
 	if (!mdss_irq_handlers[hw->hw_ndx])
 		mdss_irq_handlers[hw->hw_ndx] = hw;
 	else
-		pr_err("panel %d's irq at %pK is already registered\n",
+		pr_err("panel %d's irq at %p is already registered\n",
 			hw->hw_ndx, hw->irq_handler);
 	spin_unlock_irqrestore(&mdss_lock, irq_flags);
 
diff --git a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
index 04ba7a00bb2..1514f021414 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
@@ -5599,7 +5599,7 @@ static int is_timer_handle_valid(struct mhl_dev_context *dev_context,
 	}
 
 	if (timer != timer_handle) {
-		MHL_TX_DBG_WARN("Invalid timer handle %pK received\n",
+		MHL_TX_DBG_WARN("Invalid timer handle %p received\n",
 				timer_handle);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mhl3/mhl_supp.c b/drivers/video/msm/mdss/mhl3/mhl_supp.c
index 29de6d0b640..7055d8cd758 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_supp.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_supp.c
@@ -185,7 +185,7 @@ static struct cbus_req *get_free_cbus_queue_entry_impl(
 	req->function = function;
 	req->line = line;
 	req->sequence = dev_context->sequence++;
-	/*MHL_TX_DBG_ERR(,"q %d get:0x%pK %s:%d\n",
+	/*MHL_TX_DBG_ERR(,"q %d get:0x%p %s:%d\n",
 		req->sequence,req,function,line); */
 	return req;
 }
@@ -197,7 +197,7 @@ static void return_cbus_queue_entry_impl(struct mhl_dev_context *dev_context,
 					 struct cbus_req *pReq,
 					 const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->cbus_free_list);
 
 }
@@ -372,7 +372,7 @@ static struct block_req *start_new_block_marshalling_req_impl(
 	    sizeof(payload->as_bytes) -
 	    sizeof(struct SI_PACK_THIS_STRUCT standard_transport_header_t);
 	dev_context->block_protocol.marshalling_req = req;
-	MHL_TX_DBG_WARN("q %d get:0x%pK %s:%d\n", req->sequence, req, function,
+	MHL_TX_DBG_WARN("q %d get:0x%p %s:%d\n", req->sequence, req, function,
 			line);
 	return req;
 }
@@ -384,7 +384,7 @@ static void return_block_queue_entry_impl(struct mhl_dev_context *dev_context,
 					  struct block_req *pReq,
 					  const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->block_protocol.free_list);
 
 }
@@ -1283,7 +1283,7 @@ void si_mhl_tx_drive_states(struct mhl_dev_context *dev_context)
 	if (req == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("req: %pK\n", req);
+	MHL_TX_DBG_INFO("req: %p\n", req);
 	/* coordinate write burst requests and grants. */
 	if (MHL_MSC_MSG == req->command) {
 		dev_context->msc_msg_last_data = req->msg_data[1];
@@ -1298,7 +1298,7 @@ void si_mhl_tx_drive_states(struct mhl_dev_context *dev_context)
 		}
 	}
 
-	MHL_TX_DBG_INFO("req: %pK\n", req);
+	MHL_TX_DBG_INFO("req: %p\n", req);
 	if (req) {
 		uint8_t ret_val;
 		dev_context->current_cbus_req = req;
diff --git a/drivers/video/msm/mdss/mhl3/platform.c b/drivers/video/msm/mdss/mhl3/platform.c
index b0c7e8aabb2..c0e5174880b 100644
--- a/drivers/video/msm/mdss/mhl3/platform.c
+++ b/drivers/video/msm/mdss/mhl3/platform.c
@@ -1590,7 +1590,7 @@ static int __devinit si_8620_mhl_tx_i2c_probe(struct i2c_client *client,
 {
 	int ret;
 
-	pr_info("%s(), i2c_device_id = %pK\n", __func__, id);
+	pr_info("%s(), i2c_device_id = %p\n", __func__, id);
 
 #if defined(SIMG_USE_DTS)
 	/*
@@ -1844,7 +1844,7 @@ static int __devinit si_8620_mhl_tx_spi_probe(struct spi_device *spi)
 {
 	int ret;
 
-	pr_info("%s(), spi = %pK\n", __func__, spi);
+	pr_info("%s(), spi = %p\n", __func__, spi);
 	spi->bits_per_word = 8;
 	spi_dev = spi;
 	spi_bus_num = spi->master->bus_num;
@@ -2161,7 +2161,7 @@ static void __exit si_8620_exit(void)
 		for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
 			MHL_TX_DBG_INFO("\n");
 			if (device_addresses[idx].client != NULL) {
-				MHL_TX_DBG_INFO("unregistering device:%pK\n",
+				MHL_TX_DBG_INFO("unregistering device:%p\n",
 						device_addresses[idx].client);
 				i2c_unregister_device(device_addresses[idx].
 						      client);
diff --git a/drivers/video/msm/mdss/mhl3/si_8620_drv.c b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
index 9d68f285d58..dd71f1becd1 100644
--- a/drivers/video/msm/mdss/mhl3/si_8620_drv.c
+++ b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
@@ -2367,7 +2367,7 @@ int si_mhl_tx_drv_get_edid_fifo_partial_block(struct drv_hw_context *hw_context,
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 	offset += start;
 
-	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
 	if (EDID_BLOCK_SIZE == (offset + length))
 		hw_context->edid_fifo_block_number++;
 
@@ -2401,7 +2401,7 @@ int si_mhl_tx_drv_get_edid_fifo_next_block(struct drv_hw_context *hw_context,
 
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 
-	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
 	hw_context->edid_fifo_block_number++;
 
 #ifdef MANUAL_EDID_FETCH
diff --git a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
index 51e2eda2827..17d33c99ef5 100644
--- a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
+++ b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
@@ -461,7 +461,7 @@ static int mhl3_send_ack(struct mhl3_hid_data *mhid, uint8_t reason)
 		return -ENODEV;
 
 	MHL3_HID_DBG_WARN("%s - HID_ACK reason code: %02X\n", __func__, reason);
-	MHL3_HID_DBG_ERR("mhid->mdev: %pK\n", mhid->mdev);
+	MHL3_HID_DBG_ERR("mhid->mdev: %p\n", mhid->mdev);
 	mhid->out_data[0] = MHL3_HID_ACK;
 	mhid->out_data[1] = reason;
 
@@ -1089,7 +1089,7 @@ mhid_cleanup:
 	mhl3_send_ack(mhid, HID_ACK_NODEV);
 
 	mhid->flags |= HID_FLAGS_WQ_CANCEL;
-	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %pK\n", mhid);
+	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %p\n", mhid);
 	mhl3_disconnect_and_destroy_hid_device(mhid);
 
 	/*
diff --git a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
index 229666fe65f..13d2a08831a 100644
--- a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
+++ b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
@@ -80,11 +80,10 @@ static void destroy_mouse(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_mouse == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
 			dev_context->mdt_devs.dev_mouse);
 	input_unregister_device(dev_context->mdt_devs.dev_mouse);
-	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
-			 dev_context->mdt_devs.dev_mouse);
+	MHL_TX_DBG_INFO("Freeing mouse: %p\n", dev_context->mdt_devs.dev_mouse);
 	input_free_device(dev_context->mdt_devs.dev_mouse);
 	dev_context->mdt_devs.dev_mouse = NULL;
 }
@@ -94,10 +93,10 @@ static void destroy_keyboard(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_keyboard == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering keyboard: %pK\n",
+	MHL_TX_DBG_INFO("Unregistering keyboard: %p\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_unregister_device(dev_context->mdt_devs.dev_keyboard);
-	MHL_TX_DBG_INFO("Freeing keyboard: %pK\n",
+	MHL_TX_DBG_INFO("Freeing keyboard: %p\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_free_device(dev_context->mdt_devs.dev_keyboard);
 	dev_context->mdt_devs.dev_keyboard = NULL;
@@ -108,10 +107,10 @@ static void destroy_touchscreen(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_touchscreen == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_unregister_device(dev_context->mdt_devs.dev_touchscreen);
-	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
+	MHL_TX_DBG_INFO("Freeing mouse: %p\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_free_device(dev_context->mdt_devs.dev_touchscreen);
 	dev_context->mdt_devs.dev_touchscreen = NULL;
@@ -131,7 +130,7 @@ int init_mdt_keyboard(struct mhl_dev_context *dev_context)
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated keyboard: %pK\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Allocated keyboard: %p\n", dev_keyboard);
 
 	set_bit(EV_KEY, dev_keyboard->evbit);
 	set_bit(EV_REP, dev_keyboard->evbit);
@@ -159,7 +158,7 @@ int init_mdt_keyboard(struct mhl_dev_context *dev_context)
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered keyboard: %pK\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Registered keyboard: %p\n", dev_keyboard);
 
 	dev_context->mdt_devs.dev_keyboard = dev_keyboard;
 
@@ -176,7 +175,7 @@ int init_mdt_mouse(struct mhl_dev_context *dev_context)
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated mouse: %pK\n", dev_mouse);
+	MHL_TX_DBG_INFO("Allocated mouse: %p\n", dev_mouse);
 
 	set_bit(EV_REL, dev_mouse->evbit);
 	set_bit(EV_KEY, dev_mouse->evbit);
@@ -209,7 +208,7 @@ int init_mdt_mouse(struct mhl_dev_context *dev_context)
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered mouse: %pK\n", dev_mouse);
+	MHL_TX_DBG_INFO("Registered mouse: %p\n", dev_mouse);
 
 	dev_context->mdt_devs.dev_mouse = dev_mouse;
 
@@ -227,7 +226,7 @@ int init_mdt_touchscreen(struct mhl_dev_context *dev_context)
 		return -ENOMEM;
 	}
 
-	MHL_TX_DBG_INFO("Allocated touch screen: %pK\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Allocated touch screen: %p\n", dev_touchscreen);
 
 #if !defined(SINGLE_TOUCH) && defined(KERNEL_2_6_38_AND_LATER)
 	input_mt_init_slots(dev_touchscreen, MAX_TOUCH_CONTACTS);
@@ -302,7 +301,7 @@ int init_mdt_touchscreen(struct mhl_dev_context *dev_context)
 		input_free_device(dev_touchscreen);
 		return error;
 	}
-	MHL_TX_DBG_INFO("Registered touchscreen: %pK\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Registered touchscreen: %p\n", dev_touchscreen);
 
 	dev_context->mdt_devs.dev_touchscreen = dev_touchscreen;
 
diff --git a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
index e4408b8ce56..fd6918fbf1f 100644
--- a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
+++ b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
@@ -1118,7 +1118,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 			if ((0 != p_desc->dtd.pixel_clock_low) ||
 				(0 != p_desc->dtd.pixel_clock_high)) {
 				MHL_TX_EDID_INFO(
-					"pix clock non-zero p_desc:%pK", p_desc)
+					"pix clock non-zero p_desc:%p", p_desc)
 				if ((0 == p_desc->dtd.horz_active_7_0) &&
 				    (0 == p_desc->dtd.horz_active_blanking_high.
 					horz_active_11_8)) {
@@ -1133,7 +1133,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 						 * one by one
 						 */
 						MHL_TX_EDID_INFO(
-						"p_desc:%pK p_next_desc:%pK\n",
+						"p_desc:%p p_next_desc:%p\n",
 						p_desc, p_next_desc)
 						*p_desc++ = *p_next_desc++;
 					}
@@ -1144,7 +1144,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 					p_desc = p_holder;
 				} else {
 					p_desc++;
-					MHL_TX_EDID_INFO("p_desc:%pK\n", p_desc)
+					MHL_TX_EDID_INFO("p_desc:%p\n", p_desc)
 				}
 			}
 		}
@@ -1446,7 +1446,7 @@ static bool si_mhl_tx_parse_detailed_timing_descriptor(
 			 * Mark this mode for pruning by setting
 			 * horizontal active to zero
 			 */
-			MHL_TX_DBG_ERR("%smark for pruning%s %pK\n",
+			MHL_TX_DBG_ERR("%smark for pruning%s %p\n",
 				ANSI_ESC_YELLOW_TEXT,
 				ANSI_ESC_RESET_TEXT,
 				p_desc);
@@ -1500,7 +1500,7 @@ static uint8_t si_mhl_tx_parse_861_long_descriptors(
 				++mhl_edid_3d_data->parse_data.
 				    num_cea_861_timing_dtds;
 			} else if (valid) {
-				MHL_TX_EDID_INFO("stopping at %pK\n",
+				MHL_TX_EDID_INFO("stopping at %p\n",
 					p_data_u.p_long_descriptors)
 				break;
 			}
@@ -1600,7 +1600,7 @@ static void prune_hdmi_vsdb_vic_list(
 		HDMI_VIC_len = inner_loop_limit;
 	p_CEA_extension->byte_offset_to_18_byte_descriptors -=
 	    num_HDMI_VICs_pruned;
-	MHL_TX_EDID_INFO("%pK\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
+	MHL_TX_EDID_INFO("%p\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
 	if (mhl_edid_3d_data->parse_data.p_HDMI_vsdb) {
 		mhl_edid_3d_data->parse_data.p_HDMI_vsdb->
 		    header.fields.length_following_header -=
@@ -1722,7 +1722,8 @@ static void prune_svd_list(
 					   ("\n\nInvalid extension size\n\n"));
 				while (pb_src < pb_limit) {
 					MHL_TX_EDID_INFO(
-					    "moving data up %pK(0x%02X)<- %pK(0x%02X)\n",
+					    "moving data up %p(0x%02X) "
+					    "<- %p(0x%02X)\n",
 					    pb_dest, (uint16_t)*pb_dest,
 					    pb_src, (uint16_t)*pb_src);
 					*pb_dest++ = *pb_src++;
@@ -3122,7 +3123,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 				     ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
 				return;
 			} else {
-				MHL_TX_DBG_WARN(" %d %pK\n", hev_index,
+				MHL_TX_DBG_WARN(" %d %p\n", hev_index,
 					mhl_edid_3d_data->hev_vic_list)
 				mhl_edid_3d_data->hev_vic_info.
 				    num_items_allocated =
@@ -3135,7 +3136,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 		MHL_TX_DBG_ERR("bogus write burst, no hev_vic_list\n")
 		return;
 	}
-	MHL_TX_DBG_WARN(" %d %pK\n", hev_index, mhl_edid_3d_data->hev_vic_list)
+	MHL_TX_DBG_WARN(" %d %p\n", hev_index, mhl_edid_3d_data->hev_vic_list)
 	if (NULL == mhl_edid_3d_data->hev_vic_list) {
 		MHL_TX_DBG_ERR("%s no place to put HEV_VIC burst%s\n",
 			       ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
@@ -3154,7 +3155,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 		     burst_id_HEV_VIC,
 		     (union video_burst_descriptor_u *) &p_burst->
 		     video_descriptors[i])) {
-			MHL_TX_DBG_INFO(" %d %pK\n",
+			MHL_TX_DBG_INFO(" %d %p\n",
 				hev_index, mhl_edid_3d_data->hev_vic_list)
 			mhl_edid_3d_data->hev_vic_list[hev_index].
 			    mhl3_hev_vic_descriptor =
@@ -4035,7 +4036,7 @@ static uint8_t parse_861_block(struct edid_3d_data_t *mhl_edid_3d_data,
 
 	mhl_edid_3d_data->parse_data.p_HDMI_vsdb = NULL;
 
-	MHL_TX_EDID_INFO("tag:place holdr EDID block:%pK\n", p_EDID_block_data);
+	MHL_TX_EDID_INFO("tag:place holder EDID block:%p\n", p_EDID_block_data);
 	if (EDID_EXTENSION_BLOCK_MAP == p_CEA_extension->tag) {
 		struct block_map_t *p_block_map;
 		int i;
@@ -4122,7 +4123,7 @@ void si_mhl_tx_handle_atomic_hw_edid_read_complete(
 		     mhl_edid_3d_data->parse_data.num_EDID_extensions;
 		     ++counter) {
 			MHL_TX_EDID_INFO
-			    (" counter:%d tag:place holder EDID block:%pK\n",
+			    (" counter:%d tag:place holder EDID block:%p\n",
 			     counter,
 			     &mhl_edid_3d_data->
 			     EDID_block_data[EDID_BLOCK_SIZE * counter]);
diff --git a/drivers/video/msm/mdss/msm_mdss_io_8974.c b/drivers/video/msm/mdss/msm_mdss_io_8974.c
index 4a93b33e7f7..bd12025d515 100644
--- a/drivers/video/msm/mdss/msm_mdss_io_8974.c
+++ b/drivers/video/msm/mdss/msm_mdss_io_8974.c
@@ -2094,10 +2094,10 @@ int mdss_dsi_post_clkoff_cb(void *priv,
 		return -EINVAL;
 	}
 
-	pdata = &ctrl->panel_data;
 	if ((clk_type & MDSS_DSI_CORE_CLK) &&
 	    (curr_state == MDSS_DSI_CLK_OFF)) {
 		sdata = ctrl->shared_data;
+		pdata = &ctrl->panel_data;
 
 		for (i = DSI_MAX_PM - 1; i >= DSI_CORE_PM; i--) {
 			if ((i != DSI_CORE_PM) &&
@@ -2115,16 +2115,6 @@ int mdss_dsi_post_clkoff_cb(void *priv,
 				ctrl->core_power = false;
 			}
 		}
-
-		/*
-		 * temp workaround until framework issues pertaining to LP2
-		 * power state transitions are fixed. For now, we internally
-		 * transition to LP2 state whenever core power is turned off
-		 * in LP1 state
-		 */
-		if (mdss_dsi_is_panel_on_lp(pdata))
-			mdss_dsi_panel_power_ctrl(pdata,
-				MDSS_PANEL_POWER_LP2);
 	}
 	return rc;
 }
@@ -2144,10 +2134,10 @@ int mdss_dsi_pre_clkon_cb(void *priv,
 		return -EINVAL;
 	}
 
-	pdata = &ctrl->panel_data;
 	if ((clk_type & MDSS_DSI_CORE_CLK) && (new_state == MDSS_DSI_CLK_ON) &&
 	    (ctrl->core_power == false)) {
 		sdata = ctrl->shared_data;
+		pdata = &ctrl->panel_data;
 		/*
 		 *              Enable DSI core power
 		 * 1.> PANEL_PM are controlled as part of
@@ -2175,15 +2165,8 @@ int mdss_dsi_pre_clkon_cb(void *priv,
 			}
 
 		}
-		/*
-		 * temp workaround until framework issues pertaining to LP2
-		 * power state transitions are fixed. For now, if we intend to
-		 * send a frame update when in LP1, we have to explicitly exit
-		 * LP2 state here
-		 */
-		if (mdss_dsi_is_panel_on_ulp(pdata))
-			mdss_dsi_panel_power_ctrl(pdata, MDSS_PANEL_POWER_LP1);
 	}
+
 	/* Disable dynamic clock gating*/
 	if (ctrl->mdss_util->dyn_clk_gating_ctrl)
 		ctrl->mdss_util->dyn_clk_gating_ctrl(0);
diff --git a/include/linux/mdss_io_util.h b/include/linux/mdss_io_util.h
index f038490e17a..6ad21e88787 100644
--- a/include/linux/mdss_io_util.h
+++ b/include/linux/mdss_io_util.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -47,20 +47,13 @@ enum dss_vreg_type {
 	DSS_REG_VS,
 };
 
-enum dss_vreg_mode {
-	DSS_REG_MODE_ENABLE,
-	DSS_REG_MODE_DISABLE,
-	DSS_REG_MODE_LP,
-	DSS_REG_MODE_ULP,
-	DSS_REG_MODE_MAX,
-};
-
 struct dss_vreg {
 	struct regulator *vreg; /* vreg handle */
 	char vreg_name[32];
 	int min_voltage;
 	int max_voltage;
-	u32 load[DSS_REG_MODE_MAX];
+	int enable_load;
+	int disable_load;
 	int pre_on_sleep;
 	int post_on_sleep;
 	int pre_off_sleep;
@@ -105,8 +98,6 @@ int msm_dss_gpio_enable(struct dss_gpio *in_gpio, int num_gpio, int enable);
 int msm_dss_config_vreg(struct device *dev, struct dss_vreg *in_vreg,
 	int num_vreg, int config);
 int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg,	int enable);
-int msm_dss_config_vreg_opt_mode(struct dss_vreg *in_vreg, int num_vreg,
-	 enum dss_vreg_mode mode);
 
 int msm_dss_get_clk(struct device *dev, struct dss_clk *clk_arry, int num_clk);
 void msm_dss_put_clk(struct dss_clk *clk_arry, int num_clk);
-- 
2.30.1


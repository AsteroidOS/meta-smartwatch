From ec7360f57562ee4b57a5aae19b549586e8a86b2b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Darrel=20Gri=C3=ABt?= <dgriet@gmail.com>
Date: Sun, 8 Jan 2023 19:04:47 +0100
Subject: [PATCH 2/2] touchscreen: raydium: Add delay for wakeup report.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

AsteroidOS requires the user to keep pressing the screen for ~200ms to wake the screen.
However, the method used here simply sends a quick event, which doesn't work in our implementation.
To solve this we simply need to make sure the the finger is held down for atleast 200ms, this is done by emulating a 300ms touch.

Signed-off-by: Darrel GriÃ«t <dgriet@gmail.com>
---
 drivers/input/touchscreen/raydium_i2c_ts.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/input/touchscreen/raydium_i2c_ts.c b/drivers/input/touchscreen/raydium_i2c_ts.c
index fabe05aa09a4..bafdbfa4b0ea 100644
--- a/drivers/input/touchscreen/raydium_i2c_ts.c
+++ b/drivers/input/touchscreen/raydium_i2c_ts.c
@@ -35,6 +35,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/device.h>
 #include <linux/of_gpio.h>
+#include <linux/wakelock.h>
 
 #if defined(CONFIG_FB)
 #include <linux/notifier.h>
@@ -150,6 +151,7 @@ unsigned int g_ui_raw_data_length = 36 * 2;    // 72 bytes
 unsigned long g_ul_addr = RAYDIUM_CHECK_I2C_CMD;
 unsigned int g_ui_length = 1;
 volatile unsigned char g_u8_unlockflag = false;
+static struct wake_lock touch_lock;
 
 /*******************************************************************************
 *  Name: raydium_gpio_configure
@@ -4118,16 +4120,18 @@ static int raydium_read_touchdata(struct raydium_ts_data *data)
 		mutex_unlock(&data->lock);
 		if (buf[0] == 1)
                 {
+			wake_lock(&touch_lock);
 			input_mt_slot(data->input_dev, 0);
 			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, 1);
 			input_report_abs(data->input_dev, ABS_MT_POSITION_X, 100);
 			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, 100);
 			input_sync(data->input_dev);
-			mdelay(1);
+			msleep(300);
 			input_mt_slot(data->input_dev, 0);
 			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, 0);
 			input_mt_report_pointer_emulation(data->input_dev, false);
 			input_sync(data->input_dev);
+			wake_unlock(&touch_lock);
 			g_uc_gesture_status = RAYDIUM_GESTURE_DISABLE;
 			printk(KERN_INFO "[touch]display wake up with unlockflag\n");
 		}
@@ -4138,16 +4142,18 @@ static int raydium_read_touchdata(struct raydium_ts_data *data)
 	}
 	else
 	{
+		wake_lock(&touch_lock);
 		input_mt_slot(data->input_dev, 0);
 		input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, 1);
 		input_report_abs(data->input_dev, ABS_MT_POSITION_X, 100);
 		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, 100);
 		input_sync(data->input_dev);
-		mdelay(1);
+		msleep(300);
 		input_mt_slot(data->input_dev, 0);
 		input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, 0);
 		input_mt_report_pointer_emulation(data->input_dev, false);
 		input_sync(data->input_dev);
+		wake_unlock(&touch_lock);
 		g_uc_gesture_status = RAYDIUM_GESTURE_DISABLE;
 		printk(KERN_INFO "[touch]display wake up\n");
 	}
@@ -5082,6 +5088,7 @@ static int raydium_ts_probe(struct i2c_client *client,
         return -ENOMEM;
     }
 
+    wake_lock_init(&touch_lock, WAKE_LOCK_SUSPEND, "touch-lock");
     mutex_init(&raydium_ts->lock);
 
     i2c_set_clientdata(client, raydium_ts);
@@ -5274,6 +5281,7 @@ pwr_deinit:
     raydium_power_init(raydium_ts, false);
 
 exit_regulator_failed:
+    wake_lock_destroy(&touch_lock);
     i2c_set_clientdata(client, NULL);
 
 parse_dt_failed:
-- 
2.39.0


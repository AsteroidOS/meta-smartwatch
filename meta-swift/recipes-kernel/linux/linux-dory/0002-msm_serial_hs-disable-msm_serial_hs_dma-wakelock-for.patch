From f48f924768a0233a00063cd84858d798f2068082 Mon Sep 17 00:00:00 2001
From: Florent Revest <revestflo@gmail.com>
Date: Wed, 25 Jan 2017 18:22:06 +0100
Subject: [PATCH] msm_serial_hs: disable msm_serial_hs_dma wakelock (for better
 or worse?)

---
 drivers/tty/serial/msm_serial_hs.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/drivers/tty/serial/msm_serial_hs.c b/drivers/tty/serial/msm_serial_hs.c
index 4286d0ee1ccd..9c03e7bea389 100644
--- a/drivers/tty/serial/msm_serial_hs.c
+++ b/drivers/tty/serial/msm_serial_hs.c
@@ -227,7 +227,7 @@ struct msm_hs_port {
 	enum msm_hs_clk_req_off_state_e clk_req_off_state;
 	atomic_t clk_count;
 	struct msm_hs_wakeup wakeup;
-	struct wake_lock dma_wake_lock;  /* held while any DMA active */
+//	struct wake_lock dma_wake_lock;  /* held while any DMA active */
 
 	struct dentry *loopback_dir;
 	struct work_struct clock_off_w; /* work for actual clock off */
@@ -678,7 +678,7 @@ static int msm_hs_remove(struct platform_device *pdev)
 	msm_uport->rx.rbuffer = 0;
 
 	wake_lock_destroy(&msm_uport->rx.wake_lock);
-	wake_lock_destroy(&msm_uport->dma_wake_lock);
+//	wake_lock_destroy(&msm_uport->dma_wake_lock);
 	destroy_workqueue(msm_uport->hsuart_wq);
 	mutex_destroy(&msm_uport->clk_mutex);
 
@@ -2089,7 +2089,7 @@ static int msm_hs_check_clock_off(struct uart_port *uport)
 	 */
 	disable_irq(uport->irq);
 
-	wake_unlock(&msm_uport->dma_wake_lock);
+//	wake_unlock(&msm_uport->dma_wake_lock);
 	spin_unlock_irqrestore(&uport->lock, flags);
 
 	mutex_unlock(&msm_uport->clk_mutex);
@@ -2290,7 +2290,7 @@ void msm_hs_request_clock_on(struct uart_port *uport)
 
 	switch (cur_clk_state) {
 	case MSM_HS_CLK_OFF:
-		wake_lock(&msm_uport->dma_wake_lock);
+//		wake_lock(&msm_uport->dma_wake_lock);
 		if (!msm_uport->obs && use_low_power_wakeup(msm_uport))
 			disable_irq_nosync(msm_uport->wakeup.irq);
 		/* uport-irq was disabled when clocked off */
@@ -2584,12 +2584,12 @@ static int msm_hs_startup(struct uart_port *uport)
 	tx->dma_base = dma_map_single(uport->dev, tx_buf->buf, UART_XMIT_SIZE,
 				      DMA_TO_DEVICE);
 
-	wake_lock(&msm_uport->dma_wake_lock);
+//	wake_lock(&msm_uport->dma_wake_lock);
 	/* turn on uart clk */
 	ret = msm_hs_init_clk(uport);
 	if (unlikely(ret)) {
 		MSM_HS_ERR("Turning ON uartclk error\n");
-		wake_unlock(&msm_uport->dma_wake_lock);
+//		wake_unlock(&msm_uport->dma_wake_lock);
 		return ret;
 	}
 
@@ -2722,7 +2722,7 @@ unconfig_uart_gpios:
 	msm_hs_unconfig_uart_gpios(uport);
 deinit_uart_clk:
 	msm_hs_clock_unvote(msm_uport);
-	wake_unlock(&msm_uport->dma_wake_lock);
+//	wake_unlock(&msm_uport->dma_wake_lock);
 
 	return ret;
 }
@@ -2739,8 +2739,8 @@ static int uartdm_init_port(struct uart_port *uport)
 	init_waitqueue_head(&tx->wait);
 	init_waitqueue_head(&msm_uport->bam_disconnect_wait);
 	wake_lock_init(&rx->wake_lock, WAKE_LOCK_SUSPEND, "msm_serial_hs_rx");
-	wake_lock_init(&msm_uport->dma_wake_lock, WAKE_LOCK_SUSPEND,
-		       "msm_serial_hs_dma");
+//	wake_lock_init(&msm_uport->dma_wake_lock, WAKE_LOCK_SUSPEND,
+//		       "msm_serial_hs_dma");
 
 	tasklet_init(&rx->tlet, msm_serial_hs_rx_tlet,
 			(unsigned long) &rx->tlet);
@@ -2766,7 +2766,7 @@ static int uartdm_init_port(struct uart_port *uport)
 	return ret;
 exit_tasklet_init:
 	wake_lock_destroy(&msm_uport->rx.wake_lock);
-	wake_lock_destroy(&msm_uport->dma_wake_lock);
+//	wake_lock_destroy(&msm_uport->dma_wake_lock);
 	tasklet_kill(&msm_uport->tx.tlet);
 	tasklet_kill(&msm_uport->rx.tlet);
 	return ret;
@@ -3419,7 +3419,7 @@ static void msm_hs_shutdown(struct uart_port *uport)
 			disable_irq(msm_uport->wakeup.irq);
 	} else {
 		disable_irq(uport->irq);
-		wake_unlock(&msm_uport->dma_wake_lock);
+//		wake_unlock(&msm_uport->dma_wake_lock);
 	}
 
 	/* make sure tx tasklet finishes */
-- 
2.11.0

